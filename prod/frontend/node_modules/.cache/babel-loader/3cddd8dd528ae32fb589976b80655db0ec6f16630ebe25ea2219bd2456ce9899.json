{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// src/constants.ts\nvar cssPrefix = \"lk\";\n\n// src/utils.ts\nimport { LocalParticipant, RemoteParticipant } from \"livekit-client\";\n\n// src/track-reference/track-reference.types.ts\nfunction isTrackReference(trackReference) {\n  if (typeof trackReference === \"undefined\") {\n    return false;\n  }\n  return isTrackReferenceSubscribed(trackReference) || isTrackReferencePublished(trackReference);\n}\nfunction isTrackReferenceSubscribed(trackReference) {\n  var _a;\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && trackReference.hasOwnProperty(\"track\") && typeof ((_a = trackReference.publication) == null ? void 0 : _a.track) !== \"undefined\";\n}\nfunction isTrackReferencePublished(trackReference) {\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && trackReference.hasOwnProperty(\"publication\") && typeof trackReference.publication !== \"undefined\";\n}\nfunction isTrackReferencePlaceholder(trackReference) {\n  if (!trackReference) {\n    return false;\n  }\n  return trackReference.hasOwnProperty(\"participant\") && trackReference.hasOwnProperty(\"source\") && typeof trackReference.publication === \"undefined\";\n}\n\n// src/track-reference/track-reference.utils.ts\nfunction getTrackReferenceId(trackReference) {\n  if (typeof trackReference === \"string\" || typeof trackReference === \"number\") {\n    return `${trackReference}`;\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.source}_placeholder`;\n  } else if (isTrackReference(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.publication.source}_${trackReference.publication.trackSid}`;\n  } else {\n    throw new Error(`Can't generate a id for the given track reference: ${trackReference}`);\n  }\n}\nfunction getTrackReferenceSource(trackReference) {\n  if (isTrackReference(trackReference)) {\n    return trackReference.publication.source;\n  } else {\n    return trackReference.source;\n  }\n}\nfunction isEqualTrackRef(a, b) {\n  if (a === void 0 || b === void 0) {\n    return false;\n  }\n  if (isTrackReference(a) && isTrackReference(b)) {\n    return a.publication.trackSid === b.publication.trackSid;\n  } else {\n    return getTrackReferenceId(a) === getTrackReferenceId(b);\n  }\n}\nfunction isTrackReferencePinned(trackReference, pinState) {\n  if (typeof pinState === \"undefined\") {\n    return false;\n  }\n  if (isTrackReference(trackReference)) {\n    return pinState.some(pinnedTrackReference => pinnedTrackReference.participant.identity === trackReference.participant.identity && isTrackReference(pinnedTrackReference) && pinnedTrackReference.publication.trackSid === trackReference.publication.trackSid);\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return pinState.some(pinnedTrackReference => pinnedTrackReference.participant.identity === trackReference.participant.identity && isTrackReferencePlaceholder(pinnedTrackReference) && pinnedTrackReference.source === trackReference.source);\n  } else {\n    return false;\n  }\n}\nfunction isPlaceholderReplacement(currentTrackRef, nextTrackRef) {\n  return isTrackReferencePlaceholder(currentTrackRef) && isTrackReference(nextTrackRef) && nextTrackRef.participant.identity === currentTrackRef.participant.identity && nextTrackRef.source === currentTrackRef.source;\n}\n\n// src/utils.ts\nfunction isLocal(p) {\n  return p instanceof LocalParticipant;\n}\nfunction isRemote(p) {\n  return p instanceof RemoteParticipant;\n}\nvar attachIfSubscribed = (publication, element) => {\n  if (!publication) return;\n  const {\n    isSubscribed,\n    track\n  } = publication;\n  if (element && track) {\n    if (isSubscribed) {\n      track.attach(element);\n    } else {\n      track.detach(element);\n    }\n  }\n};\nfunction isParticipantSourcePinned(participant, source, pinState) {\n  if (pinState === void 0) {\n    return false;\n  }\n  return pinState.some(({\n    source: pinnedSource,\n    participant: pinnedParticipant\n  }) => pinnedSource === source && pinnedParticipant.identity === participant.identity);\n}\nfunction isParticipantTrackReferencePinned(trackRef, pinState) {\n  if (pinState === void 0) {\n    return false;\n  }\n  return pinState.some(pinnedTrackRef => isEqualTrackRef(pinnedTrackRef, trackRef));\n}\nfunction getScrollBarWidth() {\n  const inner = document.createElement(\"p\");\n  inner.style.width = \"100%\";\n  inner.style.height = \"200px\";\n  const outer = document.createElement(\"div\");\n  outer.style.position = \"absolute\";\n  outer.style.top = \"0px\";\n  outer.style.left = \"0px\";\n  outer.style.visibility = \"hidden\";\n  outer.style.width = \"200px\";\n  outer.style.height = \"150px\";\n  outer.style.overflow = \"hidden\";\n  outer.appendChild(inner);\n  document.body.appendChild(outer);\n  const w1 = inner.offsetWidth;\n  outer.style.overflow = \"scroll\";\n  let w2 = inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  document.body.removeChild(outer);\n  const scrollBarWidth = w1 - w2;\n  return scrollBarWidth;\n}\n\n// src/helper/detectMobileBrowser.ts\nfunction isWeb() {\n  return typeof document !== \"undefined\";\n}\nfunction isMobileBrowser() {\n  return isWeb() ? /Mobi/i.test(window.navigator.userAgent) : false;\n}\n\n// src/helper/url-regex.ts\nfunction createUrlRegExp(options) {\n  options = __spreadValues({}, options);\n  const protocol = `(?:(?:[a-z]+:)?//)?`;\n  const auth = \"(?:\\\\S+(?::\\\\S*)?@)?\";\n  const ip = new RegExp(\"(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}\", \"g\").source;\n  const host = \"(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)\";\n  const domain = \"(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*\";\n  const tld = `(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?`;\n  const port = \"(?::\\\\d{2,5})?\";\n  const path = '(?:[/?#][^\\\\s\"]*)?';\n  const regex = `(?:${protocol}|www\\\\.)${auth}(?:localhost|${ip}|${host}${domain}${tld})${port}${path}`;\n  return options.exact ? new RegExp(`(?:^${regex}$)`, \"i\") : new RegExp(regex, \"ig\");\n}\n\n// src/helper/emailRegex.ts\nimport createEmailRegExp from \"email-regex\";\n\n// src/helper/floating-menu.ts\nimport { computePosition, flip, offset, shift } from \"@floating-ui/dom\";\nfunction computeMenuPosition(button, menu) {\n  return __async(this, null, function* () {\n    const {\n      x,\n      y\n    } = yield computePosition(button, menu, {\n      placement: \"top\",\n      middleware: [offset(6), flip(), shift({\n        padding: 5\n      })]\n    });\n    return {\n      x,\n      y\n    };\n  });\n}\nfunction wasClickOutside(insideElement, event) {\n  const isOutside = !insideElement.contains(event.target);\n  return isOutside;\n}\n\n// src/helper/tokenizer.ts\nvar createDefaultGrammar = () => {\n  return {\n    email: createEmailRegExp(),\n    url: createUrlRegExp({})\n  };\n};\nfunction tokenize(input, grammar) {\n  const matches = Object.entries(grammar).map(([type, rx], weight) => Array.from(input.matchAll(rx)).map(({\n    index,\n    0: content\n  }) => ({\n    type,\n    weight,\n    content,\n    index: index != null ? index : 0\n  }))).flat().sort((a, b) => {\n    const d = a.index - b.index;\n    return d !== 0 ? d : a.weight - b.weight;\n  }).filter(({\n    index\n  }, i, arr) => {\n    if (i === 0) return true;\n    const prev = arr[i - 1];\n    return prev.index + prev.content.length <= index;\n  });\n  const tokens = [];\n  let pos = 0;\n  for (const {\n    type,\n    content,\n    index\n  } of matches) {\n    if (index > pos) tokens.push(input.substring(pos, index));\n    tokens.push({\n      type,\n      content\n    });\n    pos = index + content.length;\n  }\n  if (input.length > pos) tokens.push(input.substring(pos));\n  return tokens;\n}\n\n// src/helper/eventGroups.ts\nimport { ParticipantEvent, RoomEvent } from \"livekit-client\";\nvar allRemoteParticipantRoomEvents = [RoomEvent.ConnectionStateChanged, RoomEvent.RoomMetadataChanged, RoomEvent.ActiveSpeakersChanged, RoomEvent.ConnectionQualityChanged, RoomEvent.ParticipantConnected, RoomEvent.ParticipantDisconnected, RoomEvent.ParticipantPermissionsChanged, RoomEvent.ParticipantMetadataChanged, RoomEvent.TrackMuted, RoomEvent.TrackUnmuted, RoomEvent.TrackPublished, RoomEvent.TrackUnpublished, RoomEvent.TrackStreamStateChanged, RoomEvent.TrackSubscriptionFailed, RoomEvent.TrackSubscriptionPermissionChanged, RoomEvent.TrackSubscriptionStatusChanged];\nvar allParticipantRoomEvents = [...allRemoteParticipantRoomEvents, RoomEvent.LocalTrackPublished, RoomEvent.LocalTrackUnpublished];\nvar allRemoteParticipantEvents = [ParticipantEvent.ConnectionQualityChanged, ParticipantEvent.IsSpeakingChanged, ParticipantEvent.ParticipantMetadataChanged, ParticipantEvent.ParticipantPermissionsChanged, ParticipantEvent.TrackMuted, ParticipantEvent.TrackUnmuted, ParticipantEvent.TrackPublished, ParticipantEvent.TrackUnpublished, ParticipantEvent.TrackStreamStateChanged, ParticipantEvent.TrackSubscriptionFailed, ParticipantEvent.TrackSubscriptionPermissionChanged, ParticipantEvent.TrackSubscriptionStatusChanged];\nvar allParticipantEvents = [...allRemoteParticipantEvents, ParticipantEvent.LocalTrackPublished, ParticipantEvent.LocalTrackUnpublished];\n\n// src/logger.ts\nimport { setLogLevel as setClientSdkLogLevel, setLogExtension as setClientSdkLogExtension, LogLevel as LogLevelEnum } from \"livekit-client\";\nimport loglevel from \"loglevel\";\nvar log = loglevel.getLogger(\"lk-components-js\");\nlog.setDefaultLevel(\"WARN\");\nfunction setLogLevel(level, options = {}) {\n  var _a;\n  log.setLevel(level);\n  setClientSdkLogLevel((_a = options.liveKitClientLogLevel) != null ? _a : level);\n}\nfunction setLogExtension(extension, options = {}) {\n  var _a;\n  const originalFactory = log.methodFactory;\n  log.methodFactory = (methodName, configLevel, loggerName) => {\n    const rawMethod = originalFactory(methodName, configLevel, loggerName);\n    const logLevel = LogLevelEnum[methodName];\n    const needLog = logLevel >= configLevel && logLevel < LogLevelEnum.silent;\n    return (msg, context) => {\n      if (context) rawMethod(msg, context);else rawMethod(msg);\n      if (needLog) {\n        extension(logLevel, msg, context);\n      }\n    };\n  };\n  log.setLevel(log.getLevel());\n  setClientSdkLogExtension((_a = options.liveKitClientLogExtension) != null ? _a : extension);\n}\n\n// src/helper/grid-layouts.ts\nvar GRID_LAYOUTS = [{\n  columns: 1,\n  rows: 1,\n  name: \"1x1\",\n  minTiles: 1,\n  maxTiles: 1,\n  minWidth: 0,\n  minHeight: 0\n}, {\n  columns: 1,\n  rows: 2,\n  name: \"1x2\",\n  minTiles: 2,\n  maxTiles: 2,\n  minWidth: 0,\n  minHeight: 0\n}, {\n  columns: 2,\n  rows: 1,\n  name: \"2x1\",\n  minTiles: 2,\n  maxTiles: 2,\n  minWidth: 900,\n  minHeight: 0\n}, {\n  columns: 2,\n  rows: 2,\n  name: \"2x2\",\n  minTiles: 3,\n  maxTiles: 4,\n  minWidth: 560,\n  minHeight: 0\n}, {\n  columns: 3,\n  rows: 3,\n  name: \"3x3\",\n  minTiles: 5,\n  maxTiles: 9,\n  minWidth: 700,\n  minHeight: 0\n}, {\n  columns: 4,\n  rows: 4,\n  name: \"4x4\",\n  minTiles: 10,\n  maxTiles: 16,\n  minWidth: 960,\n  minHeight: 0\n}, {\n  columns: 5,\n  rows: 5,\n  name: \"5x5\",\n  minTiles: 17,\n  maxTiles: 25,\n  minWidth: 1100,\n  minHeight: 0\n}];\nfunction selectGridLayout(layouts, participantCount, width, height) {\n  let currentLayoutIndex = 0;\n  let layout = layouts.find((layout_, index, allLayouts) => {\n    currentLayoutIndex = index;\n    const isBiggerLayoutAvailable = allLayouts.findIndex((l, i) => {\n      const layoutIsBiggerThanCurrent = i > index;\n      const layoutFitsSameAmountOfParticipants = l.maxTiles === layout_.maxTiles;\n      return layoutIsBiggerThanCurrent && layoutFitsSameAmountOfParticipants;\n    }) !== -1;\n    return layout_.maxTiles >= participantCount && !isBiggerLayoutAvailable;\n  });\n  if (layout === void 0) {\n    layout = layouts[layouts.length - 1];\n    if (layout) {\n      log.warn(`No layout found for: participantCount: ${participantCount}, width/height: ${width}/${height} fallback to biggest available layout (${layout.name}).`);\n    } else {\n      throw new Error(`No layout or fallback layout found.`);\n    }\n  }\n  if (width < layout.minWidth || height < layout.minHeight) {\n    if (currentLayoutIndex > 0) {\n      const smallerLayout = layouts[currentLayoutIndex - 1];\n      layout = selectGridLayout(layouts.slice(0, currentLayoutIndex), smallerLayout.maxTiles, width, height);\n    }\n  }\n  return layout;\n}\n\n// src/helper/set-helper.ts\nfunction setDifference(setA, setB) {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n\n// src/helper/featureDetection.ts\nfunction supportsScreenSharing() {\n  return typeof navigator !== \"undefined\" && navigator.mediaDevices && !!navigator.mediaDevices.getDisplayMedia;\n}\n\n// src/types.ts\nvar PIN_DEFAULT_STATE = [];\nvar WIDGET_DEFAULT_STATE = {\n  showChat: false,\n  unreadMessages: 0\n};\nfunction isSourceWitOptions(source) {\n  return typeof source === \"object\";\n}\nfunction isSourcesWithOptions(sources) {\n  return Array.isArray(sources) && sources.filter(isSourceWitOptions).length > 0;\n}\n\n// src/sorting/sort-track-bundles.ts\nimport { Track as Track2 } from \"livekit-client\";\n\n// src/sorting/base-sort-functions.ts\nimport { Track } from \"livekit-client\";\nfunction sortParticipantsByAudioLevel(a, b) {\n  return b.audioLevel - a.audioLevel;\n}\nfunction sortParticipantsByIsSpeaking(a, b) {\n  if (a.isSpeaking === b.isSpeaking) {\n    return 0;\n  } else {\n    return a.isSpeaking ? -1 : 1;\n  }\n}\nfunction sortParticipantsByLastSpokenAT(a, b) {\n  var _a, _b, _c, _d;\n  if (a.lastSpokeAt !== void 0 || b.lastSpokeAt !== void 0) {\n    return ((_b = (_a = b.lastSpokeAt) == null ? void 0 : _a.getTime()) != null ? _b : 0) - ((_d = (_c = a.lastSpokeAt) == null ? void 0 : _c.getTime()) != null ? _d : 0);\n  } else {\n    return 0;\n  }\n}\nfunction sortParticipantsByJoinedAt(a, b) {\n  var _a, _b, _c, _d;\n  return ((_b = (_a = a.joinedAt) == null ? void 0 : _a.getTime()) != null ? _b : 0) - ((_d = (_c = b.joinedAt) == null ? void 0 : _c.getTime()) != null ? _d : 0);\n}\nfunction sortTrackReferencesByType(a, b) {\n  if (isTrackReference(a)) {\n    if (isTrackReference(b)) {\n      return 0;\n    } else {\n      return -1;\n    }\n  } else if (isTrackReference(b)) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\nfunction sortTrackRefsByIsCameraEnabled(a, b) {\n  const aVideo = a.participant.isCameraEnabled;\n  const bVideo = b.participant.isCameraEnabled;\n  if (aVideo !== bVideo) {\n    if (aVideo) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    return 0;\n  }\n}\n\n// src/sorting/sort-track-bundles.ts\nfunction sortTrackReferences(tracks) {\n  const localTracks = [];\n  const screenShareTracks = [];\n  const cameraTracks = [];\n  const undefinedTracks = [];\n  tracks.forEach(trackRef => {\n    if (trackRef.participant.isLocal && trackRef.source === Track2.Source.Camera) {\n      localTracks.push(trackRef);\n    } else if (trackRef.source === Track2.Source.ScreenShare) {\n      screenShareTracks.push(trackRef);\n    } else if (trackRef.source === Track2.Source.Camera) {\n      cameraTracks.push(trackRef);\n    } else {\n      undefinedTracks.push(trackRef);\n    }\n  });\n  const sortedScreenShareTracks = sortScreenShareTracks(screenShareTracks);\n  const sortedCameraTracks = sortCameraTracks(cameraTracks);\n  return [...localTracks, ...sortedScreenShareTracks, ...sortedCameraTracks, ...undefinedTracks];\n}\nfunction sortScreenShareTracks(screenShareTracks) {\n  const localScreenShares = [];\n  const remoteScreenShares = [];\n  screenShareTracks.forEach(trackRef => {\n    if (trackRef.participant.isLocal) {\n      localScreenShares.push(trackRef);\n    } else {\n      remoteScreenShares.push(trackRef);\n    }\n  });\n  localScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  remoteScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  const sortedScreenShareTrackRefs = [...remoteScreenShares, ...localScreenShares];\n  return sortedScreenShareTrackRefs;\n}\nfunction sortCameraTracks(cameraTrackReferences) {\n  const localCameraTracks = [];\n  const remoteCameraTracks = [];\n  cameraTrackReferences.forEach(trackRef => {\n    if (trackRef.participant.isLocal) {\n      localCameraTracks.push(trackRef);\n    } else {\n      remoteCameraTracks.push(trackRef);\n    }\n  });\n  remoteCameraTracks.sort((a, b) => {\n    if (a.participant.isSpeaking && b.participant.isSpeaking) {\n      return sortParticipantsByAudioLevel(a.participant, b.participant);\n    }\n    if (a.participant.isSpeaking !== b.participant.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a.participant, b.participant);\n    }\n    if (a.participant.lastSpokeAt !== b.participant.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a.participant, b.participant);\n    }\n    if (isTrackReference(a) !== isTrackReference(b)) {\n      return sortTrackReferencesByType(a, b);\n    }\n    if (a.participant.isCameraEnabled !== b.participant.isCameraEnabled) {\n      return sortTrackRefsByIsCameraEnabled(a, b);\n    }\n    return sortParticipantsByJoinedAt(a.participant, b.participant);\n  });\n  return [...localCameraTracks, ...remoteCameraTracks];\n}\n\n// src/sorting/sort-participants.ts\nimport { LocalParticipant as LocalParticipant2 } from \"livekit-client\";\nfunction sortParticipants(participants) {\n  const sortedParticipants = [...participants];\n  sortedParticipants.sort((a, b) => {\n    if (a.isSpeaking && b.isSpeaking) {\n      return sortParticipantsByAudioLevel(a, b);\n    }\n    if (a.isSpeaking !== b.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a, b);\n    }\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a, b);\n    }\n    const aVideo = a.videoTracks.size > 0;\n    const bVideo = b.videoTracks.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n    return sortParticipantsByJoinedAt(a, b);\n  });\n  const localParticipant = sortedParticipants.find(p => p instanceof LocalParticipant2);\n  if (localParticipant) {\n    const localIdx = sortedParticipants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      sortedParticipants.splice(localIdx, 1);\n      if (sortedParticipants.length > 0) {\n        sortedParticipants.splice(0, 0, localParticipant);\n      } else {\n        sortedParticipants.push(localParticipant);\n      }\n    }\n  }\n  return sortedParticipants;\n}\n\n// src/helper/array-helper.ts\nfunction chunk(input, size) {\n  return input.reduce((arr, item, idx) => {\n    return idx % size === 0 ? [...arr, [item]] : [...arr.slice(0, -1), [...arr.slice(-1)[0], item]];\n  }, []);\n}\nfunction zip(a1, a2) {\n  const resultLength = Math.max(a1.length, a2.length);\n  return new Array(resultLength).fill([]).map((_val, idx) => [a1[idx], a2[idx]]);\n}\nfunction differenceBy(a1, a2, by) {\n  return a1.filter(c => !a2.map(v => by(v)).includes(by(c)));\n}\n\n// src/track-reference/test-utils.ts\nimport { Participant, Track as Track3, TrackPublication } from \"livekit-client\";\nfunction flatTrackReferenceArray(list) {\n  return list.map(item => {\n    if (typeof item === \"string\" || typeof item === \"number\") {\n      return `${item}`;\n    } else {\n      return getTrackReferenceId(item);\n    }\n  });\n}\n\n// src/sorting/tile-array-update.ts\nfunction visualPageChange(state, next) {\n  return {\n    dropped: differenceBy(state, next, getTrackReferenceId),\n    added: differenceBy(next, state, getTrackReferenceId)\n  };\n}\nfunction listNeedsUpdating(changes) {\n  return changes.added.length !== 0 || changes.dropped.length !== 0;\n}\nfunction findIndex(trackReference, trackReferences) {\n  const indexToReplace = trackReferences.findIndex(trackReference_ => getTrackReferenceId(trackReference_) === getTrackReferenceId(trackReference));\n  if (indexToReplace === -1) {\n    throw new Error(`Element not part of the array: ${getTrackReferenceId(trackReference)} not in ${flatTrackReferenceArray(trackReferences)}`);\n  }\n  return indexToReplace;\n}\nfunction swapItems(moveForward, moveBack, trackReferences) {\n  const indexToReplace = findIndex(moveForward, trackReferences);\n  const indexReplaceWith = findIndex(moveBack, trackReferences);\n  trackReferences.splice(indexToReplace, 1, moveBack);\n  trackReferences.splice(indexReplaceWith, 1, moveForward);\n  return trackReferences;\n}\nfunction dropItem(itemToDrop, list) {\n  const indexOfElementToDrop = findIndex(itemToDrop, list);\n  list.splice(indexOfElementToDrop, 1);\n  return list;\n}\nfunction addItem(itemToAdd, list) {\n  return [...list, itemToAdd];\n}\nfunction divideIntoPages(list, maxElementsOnPage) {\n  const pages = chunk(list, maxElementsOnPage);\n  return pages;\n}\nfunction updatePages(currentList, nextList, maxItemsOnPage) {\n  let updatedList = refreshList(currentList, nextList);\n  if (updatedList.length < nextList.length) {\n    const addedItems = differenceBy(nextList, updatedList, getTrackReferenceId);\n    updatedList = [...updatedList, ...addedItems];\n  }\n  const currentPages = divideIntoPages(updatedList, maxItemsOnPage);\n  const nextPages = divideIntoPages(nextList, maxItemsOnPage);\n  zip(currentPages, nextPages).forEach(([currentPage, nextPage], pageIndex) => {\n    if (currentPage && nextPage) {\n      const updatedPage = divideIntoPages(updatedList, maxItemsOnPage)[pageIndex];\n      const changes = visualPageChange(updatedPage, nextPage);\n      if (listNeedsUpdating(changes)) {\n        log.debug(`Detected visual changes on page: ${pageIndex}, current: ${flatTrackReferenceArray(currentPage)}, next: ${flatTrackReferenceArray(nextPage)}`, {\n          changes\n        });\n        if (changes.added.length === changes.dropped.length) {\n          zip(changes.added, changes.dropped).forEach(([added, dropped]) => {\n            if (added && dropped) {\n              updatedList = swapItems(added, dropped, updatedList);\n            } else {\n              throw new Error(`For a swap action we need a addition and a removal one is missing: ${added}, ${dropped}`);\n            }\n          });\n        }\n        if (changes.added.length === 0 && changes.dropped.length > 0) {\n          changes.dropped.forEach(item => {\n            updatedList = dropItem(item, updatedList);\n          });\n        }\n        if (changes.added.length > 0 && changes.dropped.length === 0) {\n          changes.added.forEach(item => {\n            updatedList = addItem(item, updatedList);\n          });\n        }\n      }\n    }\n  });\n  if (updatedList.length > nextList.length) {\n    const missingItems = differenceBy(updatedList, nextList, getTrackReferenceId);\n    updatedList = updatedList.filter(item => !missingItems.map(getTrackReferenceId).includes(getTrackReferenceId(item)));\n  }\n  return updatedList;\n}\nfunction refreshList(currentList, nextList) {\n  return currentList.map(currentItem => {\n    const updateForCurrentItem = nextList.find(newItem_ =>\n    // If the IDs match or ..\n    getTrackReferenceId(currentItem) === getTrackReferenceId(newItem_) ||\n    // ... if the current item is a placeholder and the new item is the track reference can replace it.\n    typeof currentItem !== \"number\" && isTrackReferencePlaceholder(currentItem) && isTrackReference(newItem_) && isPlaceholderReplacement(currentItem, newItem_));\n    return updateForCurrentItem != null ? updateForCurrentItem : currentItem;\n  });\n}\n\n// src/components/mediaToggle.ts\nimport { Track as Track7 } from \"livekit-client\";\nimport { Subject as Subject2, map as map4, startWith as startWith4 } from \"rxjs\";\n\n// src/observables/participant.ts\nimport { ParticipantEvent as ParticipantEvent2, RoomEvent as RoomEvent3, Track as Track6 } from \"livekit-client\";\nimport { map as map3, switchMap, Observable as Observable2, startWith as startWith3 } from \"rxjs\";\n\n// src/observables/room.ts\nimport { Subject, map, Observable, startWith, finalize, filter, concat } from \"rxjs\";\nimport { LocalParticipant as LocalParticipant3, Room, RoomEvent as RoomEvent2, Track as Track4 } from \"livekit-client\";\nfunction observeRoomEvents(room, ...events) {\n  const observable = new Observable(subscribe => {\n    const onRoomUpdate = () => {\n      subscribe.next(room);\n    };\n    events.forEach(evt => {\n      room.on(evt, onRoomUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        room.off(evt, onRoomUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(room));\n  return observable;\n}\nfunction roomEventSelector(room, event) {\n  const observable = new Observable(subscribe => {\n    const update = (...params) => {\n      subscribe.next(params);\n    };\n    room.on(event, update);\n    const unsubscribe = () => {\n      room.off(event, update);\n    };\n    return unsubscribe;\n  });\n  return observable;\n}\nfunction roomObserver(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.ParticipantConnected, RoomEvent2.ParticipantDisconnected, RoomEvent2.ActiveSpeakersChanged, RoomEvent2.TrackSubscribed, RoomEvent2.TrackUnsubscribed, RoomEvent2.LocalTrackPublished, RoomEvent2.LocalTrackUnpublished, RoomEvent2.AudioPlaybackStatusChanged, RoomEvent2.ConnectionStateChanged).pipe(startWith(room));\n  return observable;\n}\nfunction connectionStateObserver(room) {\n  return roomEventSelector(room, RoomEvent2.ConnectionStateChanged).pipe(map(([connectionState]) => connectionState), startWith(room.state));\n}\nfunction screenShareObserver(room) {\n  let screenShareSubscriber;\n  const observers = [];\n  const observable = new Observable(subscriber => {\n    screenShareSubscriber = subscriber;\n    return () => {\n      observers.forEach(observer => {\n        observer.unsubscribe();\n      });\n    };\n  });\n  const screenShareTracks = [];\n  const handleSub = (publication, participant) => {\n    if (publication.source !== Track4.Source.ScreenShare && publication.source !== Track4.Source.ScreenShareAudio) {\n      return;\n    }\n    let trackMap = screenShareTracks.find(tr => tr.participant.identity === participant.identity);\n    const getScreenShareTracks = participant2 => {\n      return participant2.getTracks().filter(track => (track.source === Track4.Source.ScreenShare || track.source === Track4.Source.ScreenShareAudio) && track.track);\n    };\n    if (!trackMap) {\n      trackMap = {\n        participant,\n        tracks: getScreenShareTracks(participant)\n      };\n    } else {\n      const index = screenShareTracks.indexOf(trackMap);\n      screenShareTracks.splice(index, 1);\n      trackMap.tracks = getScreenShareTracks(participant);\n    }\n    if (trackMap.tracks.length > 0) {\n      screenShareTracks.push(trackMap);\n    }\n    screenShareSubscriber.next(screenShareTracks);\n  };\n  observers.push(roomEventSelector(room, RoomEvent2.TrackSubscribed).subscribe(([, ...args]) => handleSub(...args)));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackUnsubscribed).subscribe(([, ...args]) => handleSub(...args)));\n  observers.push(roomEventSelector(room, RoomEvent2.LocalTrackPublished).subscribe(args => handleSub(...args)));\n  observers.push(roomEventSelector(room, RoomEvent2.LocalTrackUnpublished).subscribe(args => {\n    handleSub(...args);\n  }));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackMuted).subscribe(args => {\n    handleSub(...args);\n  }));\n  observers.push(roomEventSelector(room, RoomEvent2.TrackUnmuted).subscribe(args => {\n    handleSub(...args);\n  }));\n  setTimeout(() => {\n    for (const p of room.participants.values()) {\n      p.getTracks().forEach(track => {\n        handleSub(track, p);\n      });\n    }\n  }, 1);\n  return observable;\n}\nfunction roomInfoObserver(room) {\n  const observer = observeRoomEvents(room, RoomEvent2.RoomMetadataChanged, RoomEvent2.ConnectionStateChanged).pipe(map(r => {\n    return {\n      name: r.name,\n      metadata: r.metadata\n    };\n  }));\n  return observer;\n}\nfunction activeSpeakerObserver(room) {\n  return roomEventSelector(room, RoomEvent2.ActiveSpeakersChanged).pipe(map(([speakers]) => speakers));\n}\nfunction createMediaDeviceObserver(kind, onError, requestPermissions = true) {\n  var _a;\n  const onDeviceChange = () => __async(this, null, function* () {\n    try {\n      const newDevices = yield Room.getLocalDevices(kind, requestPermissions);\n      deviceSubject.next(newDevices);\n    } catch (e) {\n      onError == null ? void 0 : onError(e);\n    }\n  });\n  const deviceSubject = new Subject();\n  const observable = deviceSubject.pipe(finalize(() => {\n    var _a2;\n    (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.removeEventListener(\"devicechange\", onDeviceChange);\n  }));\n  if (typeof window !== \"undefined\") {\n    if (!window.isSecureContext) {\n      throw new Error(`Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices`);\n    }\n    (_a = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a.addEventListener(\"devicechange\", onDeviceChange);\n  }\n  return concat(Room.getLocalDevices(kind, requestPermissions).catch(e => onError == null ? void 0 : onError(e)), observable);\n}\nfunction createDataObserver(room) {\n  return roomEventSelector(room, RoomEvent2.DataReceived);\n}\nfunction roomAudioPlaybackAllowedObservable(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.AudioPlaybackStatusChanged).pipe(map(room2 => {\n    return {\n      canPlayAudio: room2.canPlaybackAudio\n    };\n  }));\n  return observable;\n}\nfunction roomVideoPlaybackAllowedObservable(room) {\n  const observable = observeRoomEvents(room, RoomEvent2.VideoPlaybackStatusChanged).pipe(map(room2 => {\n    return {\n      canPlayVideo: room2.canPlaybackVideo\n    };\n  }));\n  return observable;\n}\nfunction createActiveDeviceObservable(room, kind) {\n  return roomEventSelector(room, RoomEvent2.ActiveDeviceChanged).pipe(filter(([kindOfDevice]) => kindOfDevice === kind), map(([kind2, deviceId]) => {\n    log.debug(\"activeDeviceObservable | RoomEvent.ActiveDeviceChanged\", {\n      kind: kind2,\n      deviceId\n    });\n    return deviceId;\n  }), startWith(room.getActiveDevice(kind)));\n}\nfunction encryptionStatusObservable(room, participant) {\n  return roomEventSelector(room, RoomEvent2.ParticipantEncryptionStatusChanged).pipe(filter(([, p]) => participant.identity === (p == null ? void 0 : p.identity) || !p && participant.identity === room.localParticipant.identity), map(([encrypted]) => encrypted), startWith(participant instanceof LocalParticipant3 ? participant.isE2EEEnabled : participant.isEncrypted));\n}\n\n// src/components/mediaTrack.ts\nimport { Track as Track5 } from \"livekit-client\";\nimport { map as map2, startWith as startWith2 } from \"rxjs\";\n\n// src/styles-interface/class-prefixer.ts\nfunction prefixClass(unprefixedClassName) {\n  return `${cssPrefix}-${unprefixedClassName}`;\n}\n\n// src/components/mediaTrack.ts\nfunction setupMediaTrack(trackIdentifier) {\n  const initialPub = getTrackByIdentifier(trackIdentifier);\n  const trackObserver = observeParticipantMedia(trackIdentifier.participant).pipe(map2(() => {\n    return getTrackByIdentifier(trackIdentifier);\n  }), startWith2(initialPub));\n  const className = prefixClass(trackIdentifier.source === Track5.Source.Camera || trackIdentifier.source === Track5.Source.ScreenShare ? \"participant-media-video\" : \"participant-media-audio\");\n  return {\n    className,\n    trackObserver\n  };\n}\nfunction getTrackByIdentifier(options) {\n  if (isTrackReference(options)) {\n    return options.publication;\n  } else {\n    const {\n      source,\n      name,\n      participant\n    } = options;\n    if (source && name) {\n      return participant.getTracks().find(pub => pub.source === source && pub.trackName === name);\n    } else if (name) {\n      return participant.getTrackByName(name);\n    } else if (source) {\n      return participant.getTrack(source);\n    } else {\n      throw new Error(\"At least one of source and name needs to be defined\");\n    }\n  }\n}\n\n// src/observables/participant.ts\nfunction observeParticipantEvents(participant, ...events) {\n  const observable = new Observable2(subscribe => {\n    const onParticipantUpdate = () => {\n      subscribe.next(participant);\n    };\n    events.forEach(evt => {\n      participant.on(evt, onParticipantUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        participant.off(evt, onParticipantUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith3(participant));\n  return observable;\n}\nfunction observeParticipantMedia(participant) {\n  const participantObserver = observeParticipantEvents(participant, ParticipantEvent2.TrackMuted, ParticipantEvent2.TrackUnmuted, ParticipantEvent2.ParticipantPermissionsChanged,\n  // ParticipantEvent.IsSpeakingChanged,\n  ParticipantEvent2.TrackPublished, ParticipantEvent2.TrackUnpublished, ParticipantEvent2.LocalTrackPublished, ParticipantEvent2.LocalTrackUnpublished, ParticipantEvent2.MediaDevicesError, ParticipantEvent2.TrackSubscriptionStatusChanged\n  // ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(map3(p => {\n    const {\n      isMicrophoneEnabled,\n      isCameraEnabled,\n      isScreenShareEnabled\n    } = p;\n    const microphoneTrack = p.getTrack(Track6.Source.Microphone);\n    const cameraTrack = p.getTrack(Track6.Source.Camera);\n    const participantMedia = {\n      isCameraEnabled,\n      isMicrophoneEnabled,\n      isScreenShareEnabled,\n      cameraTrack,\n      microphoneTrack,\n      participant: p\n    };\n    return participantMedia;\n  }));\n  return participantObserver;\n}\nfunction createTrackObserver(participant, options) {\n  return observeParticipantMedia(participant).pipe(map3(() => {\n    return {\n      publication: getTrackByIdentifier(options)\n    };\n  }));\n}\nfunction participantInfoObserver(participant) {\n  const observer = observeParticipantEvents(participant, ParticipantEvent2.ParticipantMetadataChanged\n  // ParticipantEvent.LocalTrackPublished,\n  ).pipe(map3(({\n    name,\n    identity,\n    metadata\n  }) => {\n    return {\n      name,\n      identity,\n      metadata\n    };\n  }), startWith3({\n    name: participant.name,\n    identity: participant.identity,\n    metadata: participant.metadata\n  }));\n  return observer;\n}\nfunction createConnectionQualityObserver(participant) {\n  const observer = participantEventSelector(participant, ParticipantEvent2.ConnectionQualityChanged).pipe(map3(([quality]) => quality), startWith3(participant.connectionQuality));\n  return observer;\n}\nfunction participantEventSelector(participant, event) {\n  const observable = new Observable2(subscribe => {\n    const update = (...params) => {\n      subscribe.next(params);\n    };\n    participant.on(event, update);\n    const unsubscribe = () => {\n      participant.off(event, update);\n    };\n    return unsubscribe;\n  });\n  return observable;\n}\nfunction mutedObserver(trackRef) {\n  var _a, _b, _c, _d;\n  return observeParticipantEvents(trackRef.participant, ParticipantEvent2.TrackMuted, ParticipantEvent2.TrackUnmuted, ParticipantEvent2.TrackSubscribed, ParticipantEvent2.TrackUnsubscribed, ParticipantEvent2.LocalTrackPublished, ParticipantEvent2.LocalTrackUnpublished).pipe(map3(participant => {\n    var _a2, _b2;\n    const pub = (_a2 = trackRef.publication) != null ? _a2 : participant.getTrack(trackRef.source);\n    return (_b2 = pub == null ? void 0 : pub.isMuted) != null ? _b2 : true;\n  }), startWith3((_d = (_c = (_a = trackRef.publication) == null ? void 0 : _a.isMuted) != null ? _c : (_b = trackRef.participant.getTrack(trackRef.source)) == null ? void 0 : _b.isMuted) != null ? _d : true));\n}\nfunction createIsSpeakingObserver(participant) {\n  return participantEventSelector(participant, ParticipantEvent2.IsSpeakingChanged).pipe(map3(([isSpeaking]) => isSpeaking));\n}\nfunction connectedParticipantsObserver(room, options = {}) {\n  var _a;\n  let subscriber;\n  const observable = new Observable2(sub => {\n    subscriber = sub;\n    return () => listener.unsubscribe();\n  }).pipe(startWith3(Array.from(room.participants.values())));\n  const additionalRoomEvents = (_a = options.additionalRoomEvents) != null ? _a : allParticipantRoomEvents;\n  const roomEvents = Array.from(/* @__PURE__ */new Set([RoomEvent3.ParticipantConnected, RoomEvent3.ParticipantDisconnected, RoomEvent3.ConnectionStateChanged, ...additionalRoomEvents]));\n  const listener = observeRoomEvents(room, ...roomEvents).subscribe(r => subscriber == null ? void 0 : subscriber.next(Array.from(r.participants.values())));\n  if (room.participants.size > 0) {\n    subscriber == null ? void 0 : subscriber.next(Array.from(room.participants.values()));\n  }\n  return observable;\n}\nfunction connectedParticipantObserver(room, identity, options = {}) {\n  var _a;\n  const additionalEvents = (_a = options.additionalEvents) != null ? _a : allParticipantEvents;\n  const observable = observeRoomEvents(room, RoomEvent3.ParticipantConnected, RoomEvent3.ParticipantDisconnected, RoomEvent3.ConnectionStateChanged).pipe(switchMap(r => {\n    const participant = r.getParticipantByIdentity(identity);\n    if (participant) {\n      return observeParticipantEvents(participant, ...additionalEvents);\n    } else {\n      return new Observable2(subscribe => subscribe.next(void 0));\n    }\n  }), startWith3(room.getParticipantByIdentity(identity)));\n  return observable;\n}\nfunction participantPermissionObserver(participant) {\n  const observer = participantEventSelector(participant, ParticipantEvent2.ParticipantPermissionsChanged).pipe(map3(() => participant.permissions), startWith3(participant.permissions));\n  return observer;\n}\n\n// src/components/mediaToggle.ts\nfunction setupMediaToggle(source, room, options) {\n  const {\n    localParticipant\n  } = room;\n  const getSourceEnabled = (source2, localParticipant2) => {\n    let isEnabled = false;\n    switch (source2) {\n      case Track7.Source.Camera:\n        isEnabled = localParticipant2.isCameraEnabled;\n        break;\n      case Track7.Source.Microphone:\n        isEnabled = localParticipant2.isMicrophoneEnabled;\n        break;\n      case Track7.Source.ScreenShare:\n        isEnabled = localParticipant2.isScreenShareEnabled;\n        break;\n      default:\n        break;\n    }\n    return isEnabled;\n  };\n  const enabledObserver = observeParticipantMedia(localParticipant).pipe(map4(media => {\n    return getSourceEnabled(source, media.participant);\n  }), startWith4(getSourceEnabled(source, localParticipant)));\n  const pendingSubject = new Subject2();\n  const toggle = (forceState, captureOptions) => __async(this, null, function* () {\n    try {\n      captureOptions != null ? captureOptions : captureOptions = options;\n      pendingSubject.next(true);\n      switch (source) {\n        case Track7.Source.Camera:\n          yield localParticipant.setCameraEnabled(forceState != null ? forceState : !localParticipant.isCameraEnabled, captureOptions);\n          break;\n        case Track7.Source.Microphone:\n          yield localParticipant.setMicrophoneEnabled(forceState != null ? forceState : !localParticipant.isMicrophoneEnabled, captureOptions);\n          break;\n        case Track7.Source.ScreenShare:\n          yield localParticipant.setScreenShareEnabled(forceState != null ? forceState : !localParticipant.isScreenShareEnabled, captureOptions);\n          break;\n        default:\n          break;\n      }\n    } finally {\n      pendingSubject.next(false);\n    }\n  });\n  const className = prefixClass(\"button\");\n  return {\n    className,\n    toggle,\n    enabledObserver,\n    pendingObserver: pendingSubject.asObservable()\n  };\n}\nfunction setupManualToggle() {\n  let state = false;\n  const enabledSubject = new Subject2();\n  const pendingSubject = new Subject2();\n  const toggle = forceState => __async(this, null, function* () {\n    pendingSubject.next(true);\n    state = forceState != null ? forceState : !state;\n    enabledSubject.next(state);\n    pendingSubject.next(false);\n  });\n  const className = prefixClass(\"button\");\n  return {\n    className,\n    toggle,\n    enabledObserver: enabledSubject.asObservable(),\n    pendingObserver: pendingSubject.asObservable()\n  };\n}\n\n// src/components/mediaDeviceSelect.ts\nimport { Track as Track8 } from \"livekit-client\";\nimport { BehaviorSubject } from \"rxjs\";\nfunction setupDeviceSelector(kind, room, localTrack) {\n  const activeDeviceSubject = new BehaviorSubject(void 0);\n  const activeDeviceObservable = room ? createActiveDeviceObservable(room, kind) : activeDeviceSubject.asObservable();\n  const setActiveMediaDevice = (_0, ..._1) => __async(this, [_0, ..._1], function* (id, options = {}) {\n    var _a, _b, _c;\n    if (room) {\n      log.debug(`Switching active device of kind \"${kind}\" with id ${id}.`);\n      yield room.switchActiveDevice(kind, id, options.exact);\n      const actualDeviceId = (_a = room.getActiveDevice(kind)) != null ? _a : id;\n      if (actualDeviceId !== id && id !== \"default\") {\n        log.info(`We tried to select the device with id (${id}), but the browser decided to select the device with id (${actualDeviceId}) instead.`);\n      }\n      let targetTrack = void 0;\n      if (kind === \"audioinput\") targetTrack = (_b = room.localParticipant.getTrack(Track8.Source.Microphone)) == null ? void 0 : _b.track;else if (kind === \"videoinput\") {\n        targetTrack = (_c = room.localParticipant.getTrack(Track8.Source.Camera)) == null ? void 0 : _c.track;\n      }\n      const useDefault = id === \"default\" && !targetTrack || id === \"default\" && (targetTrack == null ? void 0 : targetTrack.mediaStreamTrack.label.startsWith(\"Default\"));\n      activeDeviceSubject.next(useDefault ? id : actualDeviceId);\n    } else if (localTrack) {\n      yield localTrack.setDeviceId(options.exact ? {\n        exact: id\n      } : id);\n      const actualId = yield localTrack.getDeviceId();\n      activeDeviceSubject.next(id === \"default\" && localTrack.mediaStreamTrack.label.startsWith(\"Default\") ? id : actualId);\n    } else if (activeDeviceSubject.value !== id) {\n      log.warn(\"device switch skipped, please provide either a room or a local track to switch on. \");\n      activeDeviceSubject.next(id);\n    }\n  });\n  const className = prefixClass(\"media-device-select\");\n  return {\n    className,\n    activeDeviceObservable,\n    setActiveMediaDevice\n  };\n}\n\n// src/components/disconnectButton.ts\nfunction setupDisconnectButton(room) {\n  const disconnect = stopTracks => {\n    room.disconnect(stopTracks);\n  };\n  const className = prefixClass(\"disconnect-button\");\n  return {\n    className,\n    disconnect\n  };\n}\n\n// src/components/connectionQualityIndicator.ts\nfunction setupConnectionQualityIndicator(participant) {\n  const className = prefixClass(\"connection-quality\");\n  const connectionQualityObserver = createConnectionQualityObserver(participant);\n  return {\n    className,\n    connectionQualityObserver\n  };\n}\n\n// src/components/trackMutedIndicator.ts\nimport { Track as Track9 } from \"livekit-client\";\nfunction setupTrackMutedIndicator(trackRef) {\n  let classForSource = \"track-muted-indicator-camera\";\n  switch (trackRef.source) {\n    case Track9.Source.Camera:\n      classForSource = \"track-muted-indicator-camera\";\n      break;\n    case Track9.Source.Microphone:\n      classForSource = \"track-muted-indicator-microphone\";\n      break;\n    default:\n      break;\n  }\n  const className = prefixClass(classForSource);\n  const mediaMutedObserver = mutedObserver(trackRef);\n  return {\n    className,\n    mediaMutedObserver\n  };\n}\n\n// src/components/participantName.ts\nfunction setupParticipantName(participant) {\n  const infoObserver = participantInfoObserver(participant);\n  return {\n    className: \"lk-participant-name\",\n    infoObserver\n  };\n}\n\n// src/components/participantTile.ts\nfunction setupParticipantTile() {\n  const className = prefixClass(\"participant-tile\");\n  return {\n    className\n  };\n}\n\n// src/components/chat.ts\nimport { DataPacket_Kind as DataPacket_Kind2, RoomEvent as RoomEvent4 } from \"livekit-client\";\nimport { BehaviorSubject as BehaviorSubject2, Subject as Subject3, scan, map as map6, takeUntil } from \"rxjs\";\n\n// src/observables/dataChannel.ts\nimport { DataPacket_Kind } from \"livekit-client\";\nimport { Observable as Observable3, filter as filter2, map as map5 } from \"rxjs\";\nvar DataTopic = {\n  CHAT: \"lk-chat-topic\"\n};\nfunction sendMessage(_0, _1, _2) {\n  return __async(this, arguments, function* (localParticipant, payload, topic, options = {}) {\n    const {\n      kind,\n      destination\n    } = options;\n    yield localParticipant.publishData(payload, kind != null ? kind : DataPacket_Kind.RELIABLE, {\n      destination,\n      topic\n    });\n  });\n}\nfunction setupDataMessageHandler(room, topic, onMessage) {\n  const messageObservable = createDataObserver(room).pipe(filter2(([,,, messageTopic]) => topic === void 0 || messageTopic === topic), map5(([payload, participant,, messageTopic]) => {\n    const msg = {\n      payload,\n      topic: messageTopic,\n      from: participant\n    };\n    onMessage == null ? void 0 : onMessage(msg);\n    return msg;\n  }));\n  let isSendingSubscriber;\n  const isSendingObservable = new Observable3(subscriber => {\n    isSendingSubscriber = subscriber;\n  });\n  const send = (_0, ..._1) => __async(this, [_0, ..._1], function* (payload, options = {}) {\n    isSendingSubscriber.next(true);\n    try {\n      yield sendMessage(room.localParticipant, payload, topic, options);\n    } finally {\n      isSendingSubscriber.next(false);\n    }\n  });\n  return {\n    messageObservable,\n    isSendingObservable,\n    send\n  };\n}\n\n// src/components/chat.ts\nvar encoder = new TextEncoder();\nvar decoder = new TextDecoder();\nvar topicSubjectMap = /* @__PURE__ */new Map();\nvar encode = message => encoder.encode(JSON.stringify({\n  message: message.message,\n  timestamp: message.timestamp\n}));\nvar decode = message => JSON.parse(decoder.decode(message));\nfunction setupChat(room, options) {\n  var _a, _b;\n  const onDestroyObservable = new Subject3();\n  const {\n    messageDecoder,\n    messageEncoder,\n    channelTopic\n  } = options != null ? options : {};\n  const topic = channelTopic != null ? channelTopic : DataTopic.CHAT;\n  let needsSetup = false;\n  if (!topicSubjectMap.has(room)) {\n    needsSetup = true;\n  }\n  const topicMap = (_a = topicSubjectMap.get(room)) != null ? _a : /* @__PURE__ */new Map();\n  const messageSubject = (_b = topicMap.get(topic)) != null ? _b : new Subject3();\n  topicMap.set(topic, messageSubject);\n  topicSubjectMap.set(room, topicMap);\n  if (needsSetup) {\n    const {\n      messageObservable\n    } = setupDataMessageHandler(room, topic);\n    messageObservable.pipe(takeUntil(onDestroyObservable)).subscribe(messageSubject);\n  }\n  const finalMessageDecoder = messageDecoder != null ? messageDecoder : decode;\n  const messagesObservable = messageSubject.pipe(map6(msg => {\n    const parsedMessage = finalMessageDecoder(msg.payload);\n    const newMessage = __spreadProps(__spreadValues({}, parsedMessage), {\n      from: msg.from\n    });\n    return newMessage;\n  }), scan((acc, value) => [...acc, value], []), takeUntil(onDestroyObservable));\n  const isSending$ = new BehaviorSubject2(false);\n  const finalMessageEncoder = messageEncoder != null ? messageEncoder : encode;\n  const send = message => __async(this, null, function* () {\n    const timestamp = Date.now();\n    const encodedMsg = finalMessageEncoder({\n      message,\n      timestamp\n    });\n    isSending$.next(true);\n    try {\n      yield sendMessage(room.localParticipant, encodedMsg, topic, {\n        kind: DataPacket_Kind2.RELIABLE\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic,\n        from: room.localParticipant\n      });\n    } finally {\n      isSending$.next(false);\n    }\n  });\n  function destroy() {\n    onDestroyObservable.next();\n    onDestroyObservable.complete();\n    topicSubjectMap.clear();\n  }\n  room.once(RoomEvent4.Disconnected, destroy);\n  return {\n    messageObservable: messagesObservable,\n    isSendingObservable: isSending$,\n    send\n  };\n}\n\n// src/components/startAudio.ts\nfunction setupStartAudio() {\n  const handleStartAudioPlayback = room => __async(this, null, function* () {\n    log.info(\"Start Audio for room: \", room);\n    yield room.startAudio();\n  });\n  const className = prefixClass(\"start-audio-button\");\n  return {\n    className,\n    roomAudioPlaybackAllowedObservable,\n    handleStartAudioPlayback\n  };\n}\n\n// src/components/startVideo.ts\nfunction setupStartVideo() {\n  const handleStartVideoPlayback = room => __async(this, null, function* () {\n    log.info(\"Start Video for room: \", room);\n    yield room.startVideo();\n  });\n  const className = prefixClass(\"start-audio-button\");\n  return {\n    className,\n    roomVideoPlaybackAllowedObservable,\n    handleStartVideoPlayback\n  };\n}\n\n// src/components/chatToggle.ts\nfunction setupChatToggle() {\n  const className = [prefixClass(\"button\"), prefixClass(\"chat-toggle\")].join(\" \");\n  return {\n    className\n  };\n}\n\n// src/components/focusToggle.ts\nfunction setupFocusToggle() {\n  const className = [prefixClass(\"button\"), prefixClass(\"focus-toggle-button\")].join(\" \");\n  return {\n    className\n  };\n}\n\n// src/components/clearPinButton.ts\nfunction setupClearPinButton() {\n  const className = \"lk-clear-pin-button lk-button\";\n  return {\n    className\n  };\n}\n\n// src/components/room.ts\nfunction setupLiveKitRoom() {\n  const className = \"lk-room-container\";\n  return {\n    className\n  };\n}\n\n// src/observables/track.ts\nimport { RoomEvent as RoomEvent5, TrackEvent } from \"livekit-client\";\nimport { map as map7, Observable as Observable4, startWith as startWith5 } from \"rxjs\";\nfunction trackObservable(track) {\n  const trackObserver = observeTrackEvents(track, TrackEvent.Muted, TrackEvent.Unmuted, TrackEvent.Subscribed, TrackEvent.Unsubscribed);\n  return trackObserver;\n}\nfunction observeTrackEvents(track, ...events) {\n  const observable = new Observable4(subscribe => {\n    const onTrackUpdate = () => {\n      subscribe.next(track);\n    };\n    events.forEach(evt => {\n      track.on(evt, onTrackUpdate);\n    });\n    const unsubscribe = () => {\n      events.forEach(evt => {\n        track.off(evt, onTrackUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith5(track));\n  return observable;\n}\nfunction getTrackReferences(room, sources, onlySubscribedTracks = true) {\n  const localParticipant = room.localParticipant;\n  const allParticipants = [localParticipant, ...Array.from(room.participants.values())];\n  const trackReferences = [];\n  allParticipants.forEach(participant => {\n    sources.forEach(source => {\n      const sourceReferences = Array.from(participant.tracks.values()).filter(track => track.source === source && (\n      // either return all or only the ones that are subscribed\n      !onlySubscribedTracks || track.track)).map(track => {\n        return {\n          participant,\n          publication: track,\n          source: track.source\n        };\n      });\n      trackReferences.push(...sourceReferences);\n    });\n  });\n  return {\n    trackReferences,\n    participants: allParticipants\n  };\n}\nfunction trackReferencesObservable(room, sources, options) {\n  var _a, _b;\n  const additionalRoomEvents = (_a = options.additionalRoomEvents) != null ? _a : allParticipantRoomEvents;\n  const onlySubscribedTracks = (_b = options.onlySubscribed) != null ? _b : true;\n  const roomEvents = Array.from((/* @__PURE__ */new Set([RoomEvent5.ParticipantConnected, RoomEvent5.ParticipantDisconnected, RoomEvent5.ConnectionStateChanged, RoomEvent5.LocalTrackPublished, RoomEvent5.LocalTrackUnpublished, RoomEvent5.TrackPublished, RoomEvent5.TrackUnpublished, RoomEvent5.TrackSubscriptionStatusChanged, ...additionalRoomEvents])).values());\n  const observable = observeRoomEvents(room, ...roomEvents).pipe(map7(room2 => {\n    const data = getTrackReferences(room2, sources, onlySubscribedTracks);\n    log.debug(`TrackReference[] was updated. (length ${data.trackReferences.length})`, data);\n    return data;\n  }), startWith5(getTrackReferences(room, sources, onlySubscribedTracks)));\n  return observable;\n}\n\n// src/observables/dom-event.ts\nimport { concat as concat2, distinctUntilChanged, fromEvent, map as map8, of, skipUntil, timeout } from \"rxjs\";\nfunction createInteractingObservable(htmlElement, inactiveAfter = 1e3) {\n  if (htmlElement === null) return of(false);\n  const move$ = fromEvent(htmlElement, \"mousemove\", {\n    passive: true\n  }).pipe(map8(() => true));\n  const moveAndStop$ = move$.pipe(timeout({\n    each: inactiveAfter,\n    with: () => concat2(of(false), moveAndStop$.pipe(skipUntil(move$)))\n  }), distinctUntilChanged());\n  return moveAndStop$;\n}\n\n// src/persistent-storage/local-storage-helpers.ts\nfunction saveToLocalStorage(key, value) {\n  if (typeof localStorage === \"undefined\") {\n    log.error(\"Local storage is not available.\");\n    return;\n  }\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch (error) {\n    log.error(`Error setting item to local storage: ${error}`);\n  }\n}\nfunction loadFromLocalStorage(key) {\n  if (typeof localStorage === \"undefined\") {\n    log.error(\"Local storage is not available.\");\n    return void 0;\n  }\n  try {\n    const item = localStorage.getItem(key);\n    if (!item) {\n      log.warn(`Item with key ${key} does not exist in local storage.`);\n      return void 0;\n    }\n    return JSON.parse(item);\n  } catch (error) {\n    log.error(`Error getting item from local storage: ${error}`);\n    return void 0;\n  }\n}\nfunction createLocalStorageInterface(key) {\n  return {\n    load: () => loadFromLocalStorage(key),\n    save: value => saveToLocalStorage(key, value)\n  };\n}\n\n// src/persistent-storage/user-choices.ts\nvar USER_CHOICES_KEY = `${cssPrefix}-user-choices`;\nvar defaultUserChoices = {\n  videoEnabled: true,\n  audioEnabled: true,\n  videoDeviceId: \"\",\n  audioDeviceId: \"\",\n  username: \"\",\n  e2ee: false,\n  sharedPassphrase: \"\"\n};\nvar {\n  load,\n  save\n} = createLocalStorageInterface(USER_CHOICES_KEY);\nfunction saveUserChoices(userChoices, preventSave = false) {\n  if (preventSave === true) {\n    return;\n  }\n  const _a = userChoices,\n    {\n      e2ee,\n      sharedPassphrase\n    } = _a,\n    toSave = __objRest(_a, [\"e2ee\", \"sharedPassphrase\"]);\n  save(toSave);\n}\nfunction loadUserChoices(defaults, preventLoad = false) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const fallback = {\n    videoEnabled: (_a = defaults == null ? void 0 : defaults.videoEnabled) != null ? _a : defaultUserChoices.videoEnabled,\n    audioEnabled: (_b = defaults == null ? void 0 : defaults.audioEnabled) != null ? _b : defaultUserChoices.audioEnabled,\n    videoDeviceId: (_c = defaults == null ? void 0 : defaults.videoDeviceId) != null ? _c : defaultUserChoices.videoDeviceId,\n    audioDeviceId: (_d = defaults == null ? void 0 : defaults.audioDeviceId) != null ? _d : defaultUserChoices.audioDeviceId,\n    username: (_e = defaults == null ? void 0 : defaults.username) != null ? _e : defaultUserChoices.username,\n    e2ee: (_f = defaults == null ? void 0 : defaults.e2ee) != null ? _f : defaultUserChoices.e2ee,\n    sharedPassphrase: (_g = defaults == null ? void 0 : defaults.sharedPassphrase) != null ? _g : defaultUserChoices.sharedPassphrase\n  };\n  if (preventLoad) {\n    return fallback;\n  } else {\n    const maybeLoadedObject = load();\n    const result = __spreadValues(__spreadValues({}, fallback), maybeLoadedObject != null ? maybeLoadedObject : {});\n    return result;\n  }\n}\nexport { DataTopic, GRID_LAYOUTS, PIN_DEFAULT_STATE, WIDGET_DEFAULT_STATE, activeSpeakerObserver, allParticipantEvents, allParticipantRoomEvents, allRemoteParticipantEvents, allRemoteParticipantRoomEvents, attachIfSubscribed, computeMenuPosition, connectedParticipantObserver, connectedParticipantsObserver, connectionStateObserver, createActiveDeviceObservable, createConnectionQualityObserver, createDataObserver, createDefaultGrammar, createEmailRegExp, createInteractingObservable, createIsSpeakingObserver, createMediaDeviceObserver, createTrackObserver, createUrlRegExp, cssPrefix, encryptionStatusObservable, getScrollBarWidth, getTrackByIdentifier, getTrackReferenceId, getTrackReferenceSource, isEqualTrackRef, isLocal, isMobileBrowser, isParticipantSourcePinned, isParticipantTrackReferencePinned, isPlaceholderReplacement, isRemote, isSourceWitOptions, isSourcesWithOptions, isTrackReference, isTrackReferencePinned, isTrackReferencePlaceholder, isWeb, loadUserChoices, log, mutedObserver, observeParticipantEvents, observeParticipantMedia, observeRoomEvents, observeTrackEvents, participantEventSelector, participantInfoObserver, participantPermissionObserver, roomAudioPlaybackAllowedObservable, roomEventSelector, roomInfoObserver, roomObserver, roomVideoPlaybackAllowedObservable, saveUserChoices, screenShareObserver, selectGridLayout, sendMessage, setDifference, setLogExtension, setLogLevel, setupChat, setupChatToggle, setupClearPinButton, setupConnectionQualityIndicator, setupDataMessageHandler, setupDeviceSelector, setupDisconnectButton, setupFocusToggle, setupLiveKitRoom, setupManualToggle, setupMediaToggle, setupMediaTrack, setupParticipantName, setupParticipantTile, setupStartAudio, setupStartVideo, setupTrackMutedIndicator, sortParticipants, sortTrackReferences, supportsScreenSharing, tokenize, trackObservable, trackReferencesObservable, updatePages, wasClickOutside };","map":{"version":3,"names":["cssPrefix","LocalParticipant","RemoteParticipant","isTrackReference","trackReference","isTrackReferenceSubscribed","isTrackReferencePublished","_a","hasOwnProperty","publication","track","isTrackReferencePlaceholder","getTrackReferenceId","participant","identity","source","trackSid","Error","getTrackReferenceSource","isEqualTrackRef","a","b","isTrackReferencePinned","pinState","some","pinnedTrackReference","isPlaceholderReplacement","currentTrackRef","nextTrackRef","isLocal","p","isRemote","attachIfSubscribed","element","isSubscribed","attach","detach","isParticipantSourcePinned","pinnedSource","pinnedParticipant","isParticipantTrackReferencePinned","trackRef","pinnedTrackRef","getScrollBarWidth","inner","document","createElement","style","width","height","outer","position","top","left","visibility","overflow","appendChild","body","w1","offsetWidth","w2","clientWidth","removeChild","scrollBarWidth","isWeb","isMobileBrowser","test","window","navigator","userAgent","createUrlRegExp","options","__spreadValues","protocol","auth","ip","RegExp","host","domain","tld","port","path","regex","exact","createEmailRegExp","computePosition","flip","offset","shift","computeMenuPosition","button","menu","__async","x","y","placement","middleware","padding","wasClickOutside","insideElement","event","isOutside","contains","target","createDefaultGrammar","email","url","tokenize","input","grammar","matches","Object","entries","map","type","rx","weight","Array","from","matchAll","index","content","flat","sort","d","filter","i","arr","prev","length","tokens","pos","push","substring","ParticipantEvent","RoomEvent","allRemoteParticipantRoomEvents","ConnectionStateChanged","RoomMetadataChanged","ActiveSpeakersChanged","ConnectionQualityChanged","ParticipantConnected","ParticipantDisconnected","ParticipantPermissionsChanged","ParticipantMetadataChanged","TrackMuted","TrackUnmuted","TrackPublished","TrackUnpublished","TrackStreamStateChanged","TrackSubscriptionFailed","TrackSubscriptionPermissionChanged","TrackSubscriptionStatusChanged","allParticipantRoomEvents","LocalTrackPublished","LocalTrackUnpublished","allRemoteParticipantEvents","IsSpeakingChanged","allParticipantEvents","setLogLevel","setClientSdkLogLevel","setLogExtension","setClientSdkLogExtension","LogLevel","LogLevelEnum","loglevel","log","getLogger","setDefaultLevel","level","setLevel","liveKitClientLogLevel","extension","originalFactory","methodFactory","methodName","configLevel","loggerName","rawMethod","logLevel","needLog","silent","msg","context","getLevel","liveKitClientLogExtension","GRID_LAYOUTS","columns","rows","name","minTiles","maxTiles","minWidth","minHeight","selectGridLayout","layouts","participantCount","currentLayoutIndex","layout","find","layout_","allLayouts","isBiggerLayoutAvailable","findIndex","l","layoutIsBiggerThanCurrent","layoutFitsSameAmountOfParticipants","warn","smallerLayout","slice","setDifference","setA","setB","_difference","Set","elem","delete","supportsScreenSharing","mediaDevices","getDisplayMedia","PIN_DEFAULT_STATE","WIDGET_DEFAULT_STATE","showChat","unreadMessages","isSourceWitOptions","isSourcesWithOptions","sources","isArray","Track","Track2","sortParticipantsByAudioLevel","audioLevel","sortParticipantsByIsSpeaking","isSpeaking","sortParticipantsByLastSpokenAT","_b","_c","_d","lastSpokeAt","getTime","sortParticipantsByJoinedAt","joinedAt","sortTrackReferencesByType","sortTrackRefsByIsCameraEnabled","aVideo","isCameraEnabled","bVideo","sortTrackReferences","tracks","localTracks","screenShareTracks","cameraTracks","undefinedTracks","forEach","Source","Camera","ScreenShare","sortedScreenShareTracks","sortScreenShareTracks","sortedCameraTracks","sortCameraTracks","localScreenShares","remoteScreenShares","sortedScreenShareTrackRefs","cameraTrackReferences","localCameraTracks","remoteCameraTracks","LocalParticipant2","sortParticipants","participants","sortedParticipants","videoTracks","size","localParticipant","localIdx","indexOf","splice","chunk","reduce","item","idx","zip","a1","a2","resultLength","Math","max","fill","_val","differenceBy","by","c","v","includes","Participant","Track3","TrackPublication","flatTrackReferenceArray","list","visualPageChange","state","next","dropped","added","listNeedsUpdating","changes","trackReferences","indexToReplace","trackReference_","swapItems","moveForward","moveBack","indexReplaceWith","dropItem","itemToDrop","indexOfElementToDrop","addItem","itemToAdd","divideIntoPages","maxElementsOnPage","pages","updatePages","currentList","nextList","maxItemsOnPage","updatedList","refreshList","addedItems","currentPages","nextPages","currentPage","nextPage","pageIndex","updatedPage","debug","missingItems","currentItem","updateForCurrentItem","newItem_","Track7","Subject","Subject2","map4","startWith","startWith4","ParticipantEvent2","RoomEvent3","Track6","map3","switchMap","Observable","Observable2","startWith3","finalize","concat","LocalParticipant3","Room","RoomEvent2","Track4","observeRoomEvents","room","events","observable","subscribe","onRoomUpdate","evt","on","unsubscribe","off","pipe","roomEventSelector","update","params","roomObserver","TrackSubscribed","TrackUnsubscribed","AudioPlaybackStatusChanged","connectionStateObserver","connectionState","screenShareObserver","screenShareSubscriber","observers","subscriber","observer","handleSub","ScreenShareAudio","trackMap","tr","getScreenShareTracks","participant2","getTracks","args","setTimeout","values","roomInfoObserver","r","metadata","activeSpeakerObserver","speakers","createMediaDeviceObserver","kind","onError","requestPermissions","onDeviceChange","newDevices","getLocalDevices","deviceSubject","e","_a2","removeEventListener","isSecureContext","addEventListener","catch","createDataObserver","DataReceived","roomAudioPlaybackAllowedObservable","room2","canPlayAudio","canPlaybackAudio","roomVideoPlaybackAllowedObservable","VideoPlaybackStatusChanged","canPlayVideo","canPlaybackVideo","createActiveDeviceObservable","ActiveDeviceChanged","kindOfDevice","kind2","deviceId","getActiveDevice","encryptionStatusObservable","ParticipantEncryptionStatusChanged","encrypted","isE2EEEnabled","isEncrypted","Track5","map2","startWith2","prefixClass","unprefixedClassName","setupMediaTrack","trackIdentifier","initialPub","getTrackByIdentifier","trackObserver","observeParticipantMedia","className","pub","trackName","getTrackByName","getTrack","observeParticipantEvents","onParticipantUpdate","participantObserver","MediaDevicesError","isMicrophoneEnabled","isScreenShareEnabled","microphoneTrack","Microphone","cameraTrack","participantMedia","createTrackObserver","participantInfoObserver","createConnectionQualityObserver","participantEventSelector","quality","connectionQuality","mutedObserver","_b2","isMuted","createIsSpeakingObserver","connectedParticipantsObserver","sub","listener","additionalRoomEvents","roomEvents","connectedParticipantObserver","additionalEvents","getParticipantByIdentity","participantPermissionObserver","permissions","setupMediaToggle","getSourceEnabled","source2","localParticipant2","isEnabled","enabledObserver","media","pendingSubject","toggle","forceState","captureOptions","setCameraEnabled","setMicrophoneEnabled","setScreenShareEnabled","pendingObserver","asObservable","setupManualToggle","enabledSubject","Track8","BehaviorSubject","setupDeviceSelector","localTrack","activeDeviceSubject","activeDeviceObservable","setActiveMediaDevice","_0","_1","id","switchActiveDevice","actualDeviceId","info","targetTrack","useDefault","mediaStreamTrack","label","startsWith","setDeviceId","actualId","getDeviceId","value","setupDisconnectButton","disconnect","stopTracks","setupConnectionQualityIndicator","connectionQualityObserver","Track9","setupTrackMutedIndicator","classForSource","mediaMutedObserver","setupParticipantName","infoObserver","setupParticipantTile","DataPacket_Kind","DataPacket_Kind2","RoomEvent4","BehaviorSubject2","Subject3","scan","map6","takeUntil","Observable3","filter2","map5","DataTopic","CHAT","sendMessage","_2","arguments","payload","topic","destination","publishData","RELIABLE","setupDataMessageHandler","onMessage","messageObservable","messageTopic","isSendingSubscriber","isSendingObservable","send","encoder","TextEncoder","decoder","TextDecoder","topicSubjectMap","Map","encode","message","JSON","stringify","timestamp","decode","parse","setupChat","onDestroyObservable","messageDecoder","messageEncoder","channelTopic","needsSetup","has","topicMap","get","messageSubject","set","finalMessageDecoder","messagesObservable","parsedMessage","newMessage","__spreadProps","acc","isSending$","finalMessageEncoder","Date","now","encodedMsg","destroy","complete","clear","once","Disconnected","setupStartAudio","handleStartAudioPlayback","startAudio","setupStartVideo","handleStartVideoPlayback","startVideo","setupChatToggle","join","setupFocusToggle","setupClearPinButton","setupLiveKitRoom","RoomEvent5","TrackEvent","map7","Observable4","startWith5","trackObservable","observeTrackEvents","Muted","Unmuted","Subscribed","Unsubscribed","onTrackUpdate","getTrackReferences","onlySubscribedTracks","allParticipants","sourceReferences","trackReferencesObservable","onlySubscribed","data","concat2","distinctUntilChanged","fromEvent","map8","of","skipUntil","timeout","createInteractingObservable","htmlElement","inactiveAfter","move$","passive","moveAndStop$","each","with","saveToLocalStorage","key","localStorage","error","setItem","loadFromLocalStorage","getItem","createLocalStorageInterface","load","save","USER_CHOICES_KEY","defaultUserChoices","videoEnabled","audioEnabled","videoDeviceId","audioDeviceId","username","e2ee","sharedPassphrase","saveUserChoices","userChoices","preventSave","toSave","__objRest","loadUserChoices","defaults","preventLoad","_e","_f","_g","fallback","maybeLoadedObject","result"],"sources":["/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/constants.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/utils.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/track-reference/track-reference.types.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/track-reference/track-reference.utils.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/helper/detectMobileBrowser.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/helper/url-regex.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/helper/emailRegex.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/helper/floating-menu.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/helper/tokenizer.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/helper/eventGroups.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/logger.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/helper/grid-layouts.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/helper/set-helper.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/helper/featureDetection.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/types.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/sorting/sort-track-bundles.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/sorting/base-sort-functions.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/sorting/sort-participants.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/helper/array-helper.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/track-reference/test-utils.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/sorting/tile-array-update.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/mediaToggle.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/observables/participant.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/observables/room.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/mediaTrack.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/styles-interface/class-prefixer.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/mediaDeviceSelect.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/disconnectButton.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/connectionQualityIndicator.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/trackMutedIndicator.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/participantName.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/participantTile.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/chat.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/observables/dataChannel.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/startAudio.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/startVideo.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/chatToggle.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/focusToggle.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/clearPinButton.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/components/room.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/observables/track.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/observables/dom-event.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/persistent-storage/local-storage-helpers.ts","/Users/saniyasultanatuba/Downloads/Python-dev/llm/video_agent/prod/frontend/node_modules/@livekit/components-core/src/persistent-storage/user-choices.ts"],"sourcesContent":["export const cssPrefix = 'lk';\n","import type { Participant, Track, TrackPublication } from 'livekit-client';\nimport { LocalParticipant, RemoteParticipant } from 'livekit-client';\n\nimport type { PinState } from './types';\nimport type { TrackReference } from './track-reference';\nimport { isEqualTrackRef } from './track-reference';\n\nexport function isLocal(p: Participant) {\n  return p instanceof LocalParticipant;\n}\n\nexport function isRemote(p: Participant) {\n  return p instanceof RemoteParticipant;\n}\n\nexport const attachIfSubscribed = (\n  publication: TrackPublication | undefined,\n  element: HTMLMediaElement | null | undefined,\n) => {\n  if (!publication) return;\n  const { isSubscribed, track } = publication;\n  if (element && track) {\n    if (isSubscribed) {\n      track.attach(element);\n    } else {\n      track.detach(element);\n    }\n  }\n};\n\n/**\n * Check if the participant track source is pinned.\n * @deprecated Use {@link isParticipantTrackReferencePinned} instead.\n */\nexport function isParticipantSourcePinned(\n  participant: Participant,\n  source: Track.Source,\n  pinState: PinState | undefined,\n): boolean {\n  if (pinState === undefined) {\n    return false;\n  }\n\n  return pinState.some(\n    ({ source: pinnedSource, participant: pinnedParticipant }) =>\n      pinnedSource === source && pinnedParticipant.identity === participant.identity,\n  );\n}\n\n/**\n * Check if the participant track reference is pinned.\n */\nexport function isParticipantTrackReferencePinned(\n  trackRef: TrackReference,\n  pinState: PinState | undefined,\n): boolean {\n  if (pinState === undefined) {\n    return false;\n  }\n\n  return pinState.some((pinnedTrackRef) => isEqualTrackRef(pinnedTrackRef, trackRef));\n}\n\n/**\n * Calculates the scrollbar width by creating two HTML elements\n * and messaging the difference.\n * @internal\n */\nexport function getScrollBarWidth() {\n  const inner = document.createElement('p');\n  inner.style.width = '100%';\n  inner.style.height = '200px';\n\n  const outer = document.createElement('div');\n  outer.style.position = 'absolute';\n  outer.style.top = '0px';\n  outer.style.left = '0px';\n  outer.style.visibility = 'hidden';\n  outer.style.width = '200px';\n  outer.style.height = '150px';\n  outer.style.overflow = 'hidden';\n  outer.appendChild(inner);\n\n  document.body.appendChild(outer);\n  const w1 = inner.offsetWidth;\n  outer.style.overflow = 'scroll';\n  let w2 = inner.offsetWidth;\n  if (w1 === w2) {\n    w2 = outer.clientWidth;\n  }\n  document.body.removeChild(outer);\n  const scrollBarWidth = w1 - w2;\n  return scrollBarWidth;\n}\n","/**\n * The TrackReference type is a logical grouping of participant publication and/or subscribed track.\n *\n */\n\nimport type { Participant, Track, TrackPublication } from 'livekit-client';\n// ## TrackReference Types\n\n/** @public */\nexport type TrackReferencePlaceholder = {\n  participant: Participant;\n  publication?: never;\n  source: Track.Source;\n};\n\n/** @public */\nexport type TrackReference = {\n  participant: Participant;\n  publication: TrackPublication;\n  source: Track.Source;\n};\n\n/** @public */\nexport type TrackReferenceOrPlaceholder = TrackReference | TrackReferencePlaceholder;\n\n// ### TrackReference Type Predicates\n/** @internal */\nexport function isTrackReference(trackReference: unknown): trackReference is TrackReference {\n  if (typeof trackReference === 'undefined') {\n    return false;\n  }\n  return (\n    isTrackReferenceSubscribed(trackReference as TrackReference) ||\n    isTrackReferencePublished(trackReference as TrackReference)\n  );\n}\n\nfunction isTrackReferenceSubscribed(trackReference?: TrackReferenceOrPlaceholder): boolean {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    trackReference.hasOwnProperty('track') &&\n    typeof trackReference.publication?.track !== 'undefined'\n  );\n}\n\nfunction isTrackReferencePublished(trackReference?: TrackReferenceOrPlaceholder): boolean {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    trackReference.hasOwnProperty('publication') &&\n    typeof trackReference.publication !== 'undefined'\n  );\n}\n\nexport function isTrackReferencePlaceholder(\n  trackReference?: TrackReferenceOrPlaceholder,\n): trackReference is TrackReferencePlaceholder {\n  if (!trackReference) {\n    return false;\n  }\n  return (\n    trackReference.hasOwnProperty('participant') &&\n    trackReference.hasOwnProperty('source') &&\n    typeof trackReference.publication === 'undefined'\n  );\n}\n","import type { Track } from 'livekit-client';\nimport type { PinState } from '../types';\nimport type { TrackReferenceOrPlaceholder } from './track-reference.types';\nimport { isTrackReference, isTrackReferencePlaceholder } from './track-reference.types';\n\n/**\n * Returns a id to identify the `TrackReference` or `TrackReferencePlaceholder` based on\n * participant, track source and trackSid.\n * @remarks\n * The id pattern is: `${participantIdentity}_${trackSource}_${trackSid}` for `TrackReference`\n * and `${participantIdentity}_${trackSource}_placeholder` for `TrackReferencePlaceholder`.\n */\nexport function getTrackReferenceId(trackReference: TrackReferenceOrPlaceholder | number) {\n  if (typeof trackReference === 'string' || typeof trackReference === 'number') {\n    return `${trackReference}`;\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.source}_placeholder`;\n  } else if (isTrackReference(trackReference)) {\n    return `${trackReference.participant.identity}_${trackReference.publication.source}_${trackReference.publication.trackSid}`;\n  } else {\n    throw new Error(`Can't generate a id for the given track reference: ${trackReference}`);\n  }\n}\n\nexport type TrackReferenceId = ReturnType<typeof getTrackReferenceId>;\n\n/** Returns the Source of the TrackReference. */\nexport function getTrackReferenceSource(trackReference: TrackReferenceOrPlaceholder): Track.Source {\n  if (isTrackReference(trackReference)) {\n    return trackReference.publication.source;\n  } else {\n    return trackReference.source;\n  }\n}\n\nexport function isEqualTrackRef(\n  a?: TrackReferenceOrPlaceholder,\n  b?: TrackReferenceOrPlaceholder,\n): boolean {\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n  if (isTrackReference(a) && isTrackReference(b)) {\n    return a.publication.trackSid === b.publication.trackSid;\n  } else {\n    return getTrackReferenceId(a) === getTrackReferenceId(b);\n  }\n}\n\n/**\n * Check if the `TrackReference` is pinned.\n */\nexport function isTrackReferencePinned(\n  trackReference: TrackReferenceOrPlaceholder,\n  pinState: PinState | undefined,\n): boolean {\n  if (typeof pinState === 'undefined') {\n    return false;\n  }\n  if (isTrackReference(trackReference)) {\n    return pinState.some(\n      (pinnedTrackReference) =>\n        pinnedTrackReference.participant.identity === trackReference.participant.identity &&\n        isTrackReference(pinnedTrackReference) &&\n        pinnedTrackReference.publication.trackSid === trackReference.publication.trackSid,\n    );\n  } else if (isTrackReferencePlaceholder(trackReference)) {\n    return pinState.some(\n      (pinnedTrackReference) =>\n        pinnedTrackReference.participant.identity === trackReference.participant.identity &&\n        isTrackReferencePlaceholder(pinnedTrackReference) &&\n        pinnedTrackReference.source === trackReference.source,\n    );\n  } else {\n    return false;\n  }\n}\n\n/**\n * Check if the current `currentTrackRef` is the placeholder for next `nextTrackRef`.\n * Based on the participant identity and the source.\n * @internal\n */\nexport function isPlaceholderReplacement(\n  currentTrackRef: TrackReferenceOrPlaceholder,\n  nextTrackRef: TrackReferenceOrPlaceholder,\n) {\n  // if (typeof nextTrackRef === 'number' || typeof currentTrackRef === 'number') {\n  //   return false;\n  // }\n  return (\n    isTrackReferencePlaceholder(currentTrackRef) &&\n    isTrackReference(nextTrackRef) &&\n    nextTrackRef.participant.identity === currentTrackRef.participant.identity &&\n    nextTrackRef.source === currentTrackRef.source\n  );\n}\n","/**\n * @internal\n */\nexport function isWeb(): boolean {\n  return typeof document !== 'undefined';\n}\n\n/**\n * Mobile browser detection based on `navigator.userAgent` string.\n * Defaults to returning `false` if not in a browser.\n *\n * @remarks\n * This should only be used if feature detection or other methods do not work!\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent#mobile_device_detection\n */\nexport function isMobileBrowser(): boolean {\n  return isWeb() ? /Mobi/i.test(window.navigator.userAgent) : false;\n}\n","// The MIT License (MIT)\n\n// Copyright (c) Kevin Mårtensson <kevinmartensson@gmail.com> and Diego Perini\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\ninterface RegExOptions {\n  /**\n\t\tOnly match an exact string. Useful with `RegExp#test` to check if a string is a URL.\n\t\t@default false\n\t\t*/\n  readonly exact?: boolean;\n\n  /**\n\t\tForce URLs to start with a valid protocol or `www`. If set to `false` it'll match the TLD against a list of valid [TLDs](https://github.com/stephenmathieson/node-tlds).\n\t\t@default false\n    @deprecated This option will be removed in the next major version and has already no effect.\n\t\t*/\n  readonly strict?: boolean;\n}\n\nexport function createUrlRegExp(options: RegExOptions) {\n  options = {\n    ...options,\n  };\n\n  const protocol = `(?:(?:[a-z]+:)?//)?`;\n  const auth = '(?:\\\\S+(?::\\\\S*)?@)?';\n  const ip = new RegExp(\n    '(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\\\d|1\\\\d\\\\d|[1-9]\\\\d|\\\\d)){3}',\n    'g',\n  ).source;\n  const host = '(?:(?:[a-z\\\\u00a1-\\\\uffff0-9][-_]*)*[a-z\\\\u00a1-\\\\uffff0-9]+)';\n  const domain = '(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff0-9]-*)*[a-z\\\\u00a1-\\\\uffff0-9]+)*';\n  const tld = `(?:\\\\.(?:[a-z\\\\u00a1-\\\\uffff]{2,}))\\\\.?`;\n  const port = '(?::\\\\d{2,5})?';\n  const path = '(?:[/?#][^\\\\s\"]*)?';\n  const regex = `(?:${protocol}|www\\\\.)${auth}(?:localhost|${ip}|${host}${domain}${tld})${port}${path}`;\n\n  return options.exact ? new RegExp(`(?:^${regex}$)`, 'i') : new RegExp(regex, 'ig');\n}\n","import createEmailRegExp from 'email-regex';\n\nexport { createEmailRegExp };\n","import { computePosition, flip, offset, shift } from '@floating-ui/dom';\n\nexport async function computeMenuPosition(\n  button: HTMLElement,\n  menu: HTMLElement,\n): Promise<{ x: number; y: number }> {\n  const { x, y } = await computePosition(button, menu, {\n    placement: 'top',\n    middleware: [offset(6), flip(), shift({ padding: 5 })],\n  });\n  return { x, y };\n}\n\nexport function wasClickOutside(insideElement: HTMLElement, event: MouseEvent): boolean {\n  const isOutside = !insideElement.contains(event.target as Node);\n  return isOutside;\n}\n","import { createEmailRegExp } from './emailRegex';\nimport { createUrlRegExp } from './url-regex';\n\nexport type TokenizeGrammar = { [type: string]: RegExp };\n\nexport const createDefaultGrammar = () => {\n  return {\n    email: createEmailRegExp(),\n    url: createUrlRegExp({}),\n  } satisfies TokenizeGrammar;\n};\n\nexport function tokenize<T extends TokenizeGrammar>(input: string, grammar: T) {\n  const matches = Object.entries(grammar)\n    .map(([type, rx], weight) =>\n      Array.from(input.matchAll(rx)).map(({ index, 0: content }) => ({\n        type: type as keyof T,\n        weight,\n        content,\n        index: index ?? 0,\n      })),\n    )\n    .flat()\n    .sort((a, b) => {\n      const d = a.index - b.index;\n      return d !== 0 ? d : a.weight - b.weight;\n    })\n    .filter(({ index }, i, arr) => {\n      if (i === 0) return true;\n      const prev = arr[i - 1];\n      return prev.index + prev.content.length <= index;\n    });\n\n  const tokens = [];\n  let pos = 0;\n  for (const { type, content, index } of matches) {\n    if (index > pos) tokens.push(input.substring(pos, index));\n    tokens.push({ type, content });\n    pos = index + content.length;\n  }\n  if (input.length > pos) tokens.push(input.substring(pos));\n  return tokens;\n}\n","import { ParticipantEvent, RoomEvent } from 'livekit-client';\n\nexport const allRemoteParticipantRoomEvents = [\n  RoomEvent.ConnectionStateChanged,\n  RoomEvent.RoomMetadataChanged,\n\n  RoomEvent.ActiveSpeakersChanged,\n  RoomEvent.ConnectionQualityChanged,\n\n  RoomEvent.ParticipantConnected,\n  RoomEvent.ParticipantDisconnected,\n  RoomEvent.ParticipantPermissionsChanged,\n  RoomEvent.ParticipantMetadataChanged,\n\n  RoomEvent.TrackMuted,\n  RoomEvent.TrackUnmuted,\n  RoomEvent.TrackPublished,\n  RoomEvent.TrackUnpublished,\n  RoomEvent.TrackStreamStateChanged,\n  RoomEvent.TrackSubscriptionFailed,\n  RoomEvent.TrackSubscriptionPermissionChanged,\n  RoomEvent.TrackSubscriptionStatusChanged,\n];\n\nexport const allParticipantRoomEvents = [\n  ...allRemoteParticipantRoomEvents,\n  RoomEvent.LocalTrackPublished,\n  RoomEvent.LocalTrackUnpublished,\n];\n\nexport const allRemoteParticipantEvents = [\n  ParticipantEvent.ConnectionQualityChanged,\n  ParticipantEvent.IsSpeakingChanged,\n  ParticipantEvent.ParticipantMetadataChanged,\n  ParticipantEvent.ParticipantPermissionsChanged,\n\n  ParticipantEvent.TrackMuted,\n  ParticipantEvent.TrackUnmuted,\n  ParticipantEvent.TrackPublished,\n  ParticipantEvent.TrackUnpublished,\n  ParticipantEvent.TrackStreamStateChanged,\n  ParticipantEvent.TrackSubscriptionFailed,\n  ParticipantEvent.TrackSubscriptionPermissionChanged,\n  ParticipantEvent.TrackSubscriptionStatusChanged,\n];\n\nexport const allParticipantEvents = [\n  ...allRemoteParticipantEvents,\n  ParticipantEvent.LocalTrackPublished,\n  ParticipantEvent.LocalTrackUnpublished,\n];\n","import {\n  setLogLevel as setClientSdkLogLevel,\n  setLogExtension as setClientSdkLogExtension,\n  LogLevel as LogLevelEnum,\n} from 'livekit-client';\nimport loglevel from 'loglevel';\n\nexport const log = loglevel.getLogger('lk-components-js');\nlog.setDefaultLevel('WARN');\n\ntype LogLevel = Parameters<typeof setClientSdkLogLevel>[0];\ntype SetLogLevelOptions = {\n  liveKitClientLogLevel?: LogLevel;\n};\n\n/**\n * Set the log level for both the `@livekit/components-react` package and the `@livekit-client` package.\n * To set the `@livekit-client` log independently, use the `liveKitClientLogLevel` prop on the `options` object.\n * @public\n */\nexport function setLogLevel(level: LogLevel, options: SetLogLevelOptions = {}): void {\n  log.setLevel(level);\n  setClientSdkLogLevel(options.liveKitClientLogLevel ?? level);\n}\n\ntype LogExtension = (level: LogLevel, msg: string, context?: object) => void;\ntype SetLogExtensionOptions = {\n  liveKitClientLogExtension?: LogExtension;\n};\n\n/**\n * Set the log extension for both the `@livekit/components-react` package and the `@livekit-client` package.\n * To set the `@livekit-client` log extension, use the `liveKitClientLogExtension` prop on the `options` object.\n * @public\n */\nexport function setLogExtension(extension: LogExtension, options: SetLogExtensionOptions = {}) {\n  const originalFactory = log.methodFactory;\n\n  log.methodFactory = (methodName, configLevel, loggerName) => {\n    const rawMethod = originalFactory(methodName, configLevel, loggerName);\n\n    const logLevel = LogLevelEnum[methodName];\n    const needLog = logLevel >= configLevel && logLevel < LogLevelEnum.silent;\n\n    return (msg, context?: [msg: string, context: object]) => {\n      if (context) rawMethod(msg, context);\n      else rawMethod(msg);\n      if (needLog) {\n        extension(logLevel, msg, context);\n      }\n    };\n  };\n  log.setLevel(log.getLevel()); // Be sure to call setLevel method in order to apply plugin\n  setClientSdkLogExtension(options.liveKitClientLogExtension ?? extension);\n}\n","import { log } from '../logger';\n\nexport type GridLayoutDefinition = {\n  /** Layout name (convention `<column_count>x<row_count>`). */\n  name: string;\n  /** Column count of the layout. */\n  columns: number;\n  /** Row count of the layout. */\n  rows: number;\n  // # Constraints that have to be meet to use this layout.\n  // ## 1. Participant range:\n  /** Minimum number of tiles needed to use this layout. */\n  minTiles: number;\n  /** Maximum tiles that fit into this layout. */\n  maxTiles: number;\n  // ## 2. Screen size limits:\n  /** Minimum width required to use this layout. */\n  minWidth: number;\n  /** Minimum height required to use this layout. */\n  minHeight: number;\n};\n\nexport const GRID_LAYOUTS: GridLayoutDefinition[] = [\n  {\n    columns: 1,\n    rows: 1,\n    name: '1x1',\n    minTiles: 1,\n    maxTiles: 1,\n    minWidth: 0,\n    minHeight: 0,\n  },\n  {\n    columns: 1,\n    rows: 2,\n    name: '1x2',\n    minTiles: 2,\n    maxTiles: 2,\n    minWidth: 0,\n    minHeight: 0,\n  },\n  {\n    columns: 2,\n    rows: 1,\n    name: '2x1',\n    minTiles: 2,\n    maxTiles: 2,\n    minWidth: 900,\n    minHeight: 0,\n  },\n  {\n    columns: 2,\n    rows: 2,\n    name: '2x2',\n    minTiles: 3,\n    maxTiles: 4,\n    minWidth: 560,\n    minHeight: 0,\n  },\n  {\n    columns: 3,\n    rows: 3,\n    name: '3x3',\n    minTiles: 5,\n    maxTiles: 9,\n    minWidth: 700,\n    minHeight: 0,\n  },\n  {\n    columns: 4,\n    rows: 4,\n    name: '4x4',\n    minTiles: 10,\n    maxTiles: 16,\n    minWidth: 960,\n    minHeight: 0,\n  },\n  {\n    columns: 5,\n    rows: 5,\n    name: '5x5',\n    minTiles: 17,\n    maxTiles: 25,\n    minWidth: 1100,\n    minHeight: 0,\n  },\n];\n\nexport function selectGridLayout(\n  layouts: GridLayoutDefinition[],\n  participantCount: number,\n  width: number,\n  height: number,\n): GridLayoutDefinition {\n  // Find the best layout to fit all participants.\n  let currentLayoutIndex = 0;\n  let layout = layouts.find((layout_, index, allLayouts) => {\n    currentLayoutIndex = index;\n    const isBiggerLayoutAvailable =\n      allLayouts.findIndex((l, i) => {\n        const layoutIsBiggerThanCurrent = i > index;\n        const layoutFitsSameAmountOfParticipants = l.maxTiles === layout_.maxTiles;\n        return layoutIsBiggerThanCurrent && layoutFitsSameAmountOfParticipants;\n      }) !== -1;\n    return layout_.maxTiles >= participantCount && !isBiggerLayoutAvailable;\n  });\n  if (layout === undefined) {\n    layout = layouts[layouts.length - 1];\n    if (layout) {\n      log.warn(\n        `No layout found for: participantCount: ${participantCount}, width/height: ${width}/${height} fallback to biggest available layout (${layout.name}).`,\n      );\n    } else {\n      throw new Error(`No layout or fallback layout found.`);\n    }\n  }\n\n  // Check if the layout fits into the screen constraints. If not, recursively check the next smaller layout.\n  if (width < layout.minWidth || height < layout.minHeight) {\n    // const currentLayoutIndex = layouts.indexOf(layout);\n    if (currentLayoutIndex > 0) {\n      const smallerLayout = layouts[currentLayoutIndex - 1];\n      layout = selectGridLayout(\n        layouts.slice(0, currentLayoutIndex),\n        smallerLayout.maxTiles,\n        width,\n        height,\n      );\n    }\n  }\n  return layout;\n}\n","export function setDifference<T>(setA: Set<T>, setB: Set<T>): Set<T> {\n  const _difference = new Set(setA);\n  for (const elem of setB) {\n    _difference.delete(elem);\n  }\n  return _difference;\n}\n","/**\n * Returns `true` if the browser supports screen sharing.\n */\nexport function supportsScreenSharing(): boolean {\n  return (\n    typeof navigator !== 'undefined' &&\n    navigator.mediaDevices &&\n    !!navigator.mediaDevices.getDisplayMedia\n  );\n}\n","import type { Participant, Track, TrackPublication } from 'livekit-client';\nimport type { TrackReference, TrackReferenceOrPlaceholder } from './track-reference';\n\n// ## PinState Type\n/** @public */\nexport type PinState = TrackReferenceOrPlaceholder[];\nexport const PIN_DEFAULT_STATE: PinState = [];\n\n// ## WidgetState Types\n/** @public */\nexport type WidgetState = {\n  showChat: boolean;\n  unreadMessages: number;\n};\nexport const WIDGET_DEFAULT_STATE: WidgetState = { showChat: false, unreadMessages: 0 };\n\n// ## Track Source Types\nexport type TrackSourceWithOptions = { source: Track.Source; withPlaceholder: boolean };\n\nexport type SourcesArray = Track.Source[] | TrackSourceWithOptions[];\n\n// ### Track Source Type Predicates\nexport function isSourceWitOptions(source: SourcesArray[number]): source is TrackSourceWithOptions {\n  return typeof source === 'object';\n}\n\nexport function isSourcesWithOptions(sources: SourcesArray): sources is TrackSourceWithOptions[] {\n  return (\n    Array.isArray(sources) &&\n    (sources as TrackSourceWithOptions[]).filter(isSourceWitOptions).length > 0\n  );\n}\n\n// ## Loop Filter Types\nexport type TrackReferenceFilter = Parameters<TrackReferenceOrPlaceholder[]['filter']>['0'];\nexport type ParticipantFilter = Parameters<Participant[]['filter']>['0'];\n\n// ## Other Types\n/** @internal */\nexport interface ParticipantClickEvent {\n  participant: Participant;\n  track?: TrackPublication;\n}\n\nexport type TrackSource<T extends Track.Source> = RequireAtLeastOne<\n  { source: T; name: string; participant: Participant },\n  'name' | 'source'\n>;\n\n/**\n * The TrackIdentifier type is used to select Tracks either based on\n * - Track.Source and/or name of the track, e.g. `{source: Track.Source.Camera}` or `{name: \"my-track\"}`\n * - TrackReference (participant and publication)\n */\nexport type TrackIdentifier<T extends Track.Source = Track.Source> =\n  | TrackSource<T>\n  | TrackReference;\n\n// ## Util Types\ntype RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n  }[Keys];\n\nexport type RequireOnlyOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Record<Exclude<Keys, K>, undefined>>;\n  }[Keys];\n\nexport type AudioSource = Track.Source.Microphone | Track.Source.ScreenShareAudio;\nexport type VideoSource = Track.Source.Camera | Track.Source.ScreenShare;\n","import { Track } from 'livekit-client';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport { isTrackReference } from '../track-reference';\nimport {\n  sortParticipantsByAudioLevel,\n  sortParticipantsByIsSpeaking,\n  sortParticipantsByJoinedAt,\n  sortParticipantsByLastSpokenAT,\n  sortTrackReferencesByType,\n  sortTrackRefsByIsCameraEnabled,\n} from './base-sort-functions';\n\n/**\n * Default sort for `TrackReferenceOrPlaceholder`, it'll order participants by:\n * 1. local camera track (publication.isLocal)\n * 2. remote screen_share track\n * 3. local screen_share track\n * 4. remote dominant speaker camera track (sorted by speaker with the loudest audio level)\n * 5. other remote speakers that are recently active\n * 6. remote unmuted camera tracks\n * 7. remote tracks sorted by joinedAt\n */\nexport function sortTrackReferences(\n  tracks: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localTracks: TrackReferenceOrPlaceholder[] = [];\n  const screenShareTracks: TrackReferenceOrPlaceholder[] = [];\n  const cameraTracks: TrackReferenceOrPlaceholder[] = [];\n  const undefinedTracks: TrackReferenceOrPlaceholder[] = [];\n\n  tracks.forEach((trackRef) => {\n    if (trackRef.participant.isLocal && trackRef.source === Track.Source.Camera) {\n      localTracks.push(trackRef);\n    } else if (trackRef.source === Track.Source.ScreenShare) {\n      screenShareTracks.push(trackRef);\n    } else if (trackRef.source === Track.Source.Camera) {\n      cameraTracks.push(trackRef);\n    } else {\n      undefinedTracks.push(trackRef);\n    }\n  });\n\n  const sortedScreenShareTracks = sortScreenShareTracks(screenShareTracks);\n  const sortedCameraTracks = sortCameraTracks(cameraTracks);\n\n  return [...localTracks, ...sortedScreenShareTracks, ...sortedCameraTracks, ...undefinedTracks];\n}\n\n/**\n * Sort an array of `TrackReference` screen shares.\n * Main sorting order:\n * 1. remote screen shares\n * 2. local screen shares\n * Secondary sorting by participant's joining time.\n */\nfunction sortScreenShareTracks(\n  screenShareTracks: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localScreenShares: TrackReferenceOrPlaceholder[] = [];\n  const remoteScreenShares: TrackReferenceOrPlaceholder[] = [];\n\n  screenShareTracks.forEach((trackRef) => {\n    if (trackRef.participant.isLocal) {\n      localScreenShares.push(trackRef);\n    } else {\n      remoteScreenShares.push(trackRef);\n    }\n  });\n\n  localScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n  remoteScreenShares.sort((a, b) => sortParticipantsByJoinedAt(a.participant, b.participant));\n\n  const sortedScreenShareTrackRefs = [...remoteScreenShares, ...localScreenShares];\n  return sortedScreenShareTrackRefs;\n}\n\nfunction sortCameraTracks(\n  cameraTrackReferences: TrackReferenceOrPlaceholder[],\n): TrackReferenceOrPlaceholder[] {\n  const localCameraTracks: TrackReferenceOrPlaceholder[] = [];\n  const remoteCameraTracks: TrackReferenceOrPlaceholder[] = [];\n\n  cameraTrackReferences.forEach((trackRef) => {\n    if (trackRef.participant.isLocal) {\n      localCameraTracks.push(trackRef);\n    } else {\n      remoteCameraTracks.push(trackRef);\n    }\n  });\n\n  remoteCameraTracks.sort((a, b) => {\n    // Participant with higher audio level goes first.\n    if (a.participant.isSpeaking && b.participant.isSpeaking) {\n      return sortParticipantsByAudioLevel(a.participant, b.participant);\n    }\n\n    // A speaking participant goes before one that is not speaking.\n    if (a.participant.isSpeaking !== b.participant.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a.participant, b.participant);\n    }\n\n    // A participant that spoke recently goes before a participant that spoke a while back.\n    if (a.participant.lastSpokeAt !== b.participant.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a.participant, b.participant);\n    }\n\n    // TrackReference before TrackReferencePlaceholder\n    if (isTrackReference(a) !== isTrackReference(b)) {\n      return sortTrackReferencesByType(a, b);\n    }\n\n    // Tiles with video on before tiles with muted video track.\n    if (a.participant.isCameraEnabled !== b.participant.isCameraEnabled) {\n      return sortTrackRefsByIsCameraEnabled(a, b);\n    }\n\n    // A participant that joined a long time ago goes before one that joined recently.\n    return sortParticipantsByJoinedAt(a.participant, b.participant);\n  });\n\n  return [...localCameraTracks, ...remoteCameraTracks];\n}\n","import type { Participant } from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport { getTrackReferenceSource, isTrackReference } from '../track-reference';\n\nexport function sortParticipantsByAudioLevel(\n  a: Pick<Participant, 'audioLevel'>,\n  b: Pick<Participant, 'audioLevel'>,\n): number {\n  return b.audioLevel - a.audioLevel;\n}\n\nexport function sortParticipantsByIsSpeaking(\n  a: Pick<Participant, 'isSpeaking'>,\n  b: Pick<Participant, 'isSpeaking'>,\n): number {\n  if (a.isSpeaking === b.isSpeaking) {\n    return 0;\n  } else {\n    return a.isSpeaking ? -1 : 1;\n  }\n}\n\nexport function sortParticipantsByLastSpokenAT(\n  a: Pick<Participant, 'lastSpokeAt'>,\n  b: Pick<Participant, 'lastSpokeAt'>,\n): number {\n  if (a.lastSpokeAt !== undefined || b.lastSpokeAt !== undefined) {\n    return (b.lastSpokeAt?.getTime() ?? 0) - (a.lastSpokeAt?.getTime() ?? 0);\n  } else {\n    return 0;\n  }\n}\n\nexport function sortParticipantsByJoinedAt(\n  a: Pick<Participant, 'joinedAt'>,\n  b: Pick<Participant, 'joinedAt'>,\n) {\n  return (a.joinedAt?.getTime() ?? 0) - (b.joinedAt?.getTime() ?? 0);\n}\n\nexport function sortTrackReferencesByType(\n  a: TrackReferenceOrPlaceholder,\n  b: TrackReferenceOrPlaceholder,\n) {\n  if (isTrackReference(a)) {\n    if (isTrackReference(b)) {\n      return 0;\n    } else {\n      return -1;\n    }\n  } else if (isTrackReference(b)) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\n/** TrackReference with screen share source goes first. */\nexport function sortTrackReferencesByScreenShare(\n  a: TrackReferenceOrPlaceholder,\n  b: TrackReferenceOrPlaceholder,\n): number {\n  const sourceA = getTrackReferenceSource(a);\n  const sourceB = getTrackReferenceSource(b);\n\n  if (sourceA === sourceB) {\n    if (sourceA === Track.Source.ScreenShare) {\n      if (a.participant.isLocal === b.participant.isLocal) {\n        return 0;\n      } else {\n        return a.participant.isLocal ? 1 : -1;\n      }\n    }\n    return 0;\n  } else if (sourceA === Track.Source.ScreenShare) {\n    return -1;\n  } else if (sourceB === Track.Source.ScreenShare) {\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nexport function sortTrackRefsByIsCameraEnabled(\n  a: { participant: { isCameraEnabled: boolean } },\n  b: { participant: { isCameraEnabled: boolean } },\n) {\n  const aVideo = a.participant.isCameraEnabled;\n  const bVideo = b.participant.isCameraEnabled;\n\n  if (aVideo !== bVideo) {\n    if (aVideo) {\n      return -1;\n    } else {\n      return 1;\n    }\n  } else {\n    return 0;\n  }\n}\n","import type { Participant } from 'livekit-client';\nimport { LocalParticipant } from 'livekit-client';\nimport {\n  sortParticipantsByAudioLevel,\n  sortParticipantsByIsSpeaking,\n  sortParticipantsByJoinedAt,\n  sortParticipantsByLastSpokenAT,\n} from './base-sort-functions';\n\n/**\n * Default sort for participants, it'll order participants by:\n * 1. local participant\n * 2. dominant speaker (speaker with the loudest audio level)\n * 3. other speakers that are recently active\n * 4. participants with video on\n * 5. by joinedAt\n */\nexport function sortParticipants(participants: Participant[]): Participant[] {\n  const sortedParticipants = [...participants];\n  sortedParticipants.sort((a, b) => {\n    // loudest speaker first\n    if (a.isSpeaking && b.isSpeaking) {\n      return sortParticipantsByAudioLevel(a, b);\n    }\n\n    // speaker goes first\n    if (a.isSpeaking !== b.isSpeaking) {\n      return sortParticipantsByIsSpeaking(a, b);\n    }\n\n    // last active speaker first\n    if (a.lastSpokeAt !== b.lastSpokeAt) {\n      return sortParticipantsByLastSpokenAT(a, b);\n    }\n\n    // video on\n    const aVideo = a.videoTracks.size > 0;\n    const bVideo = b.videoTracks.size > 0;\n    if (aVideo !== bVideo) {\n      if (aVideo) {\n        return -1;\n      } else {\n        return 1;\n      }\n    }\n\n    // joinedAt\n    return sortParticipantsByJoinedAt(a, b);\n  });\n  const localParticipant = sortedParticipants.find((p) => p instanceof LocalParticipant);\n  if (localParticipant) {\n    const localIdx = sortedParticipants.indexOf(localParticipant);\n    if (localIdx >= 0) {\n      sortedParticipants.splice(localIdx, 1);\n      if (sortedParticipants.length > 0) {\n        sortedParticipants.splice(0, 0, localParticipant);\n      } else {\n        sortedParticipants.push(localParticipant);\n      }\n    }\n  }\n  return sortedParticipants;\n}\n","export function chunk<T>(input: Array<T>, size: number) {\n  return input.reduce(\n    (arr, item, idx) => {\n      return idx % size === 0\n        ? [...arr, [item]]\n        : [...arr.slice(0, -1), [...arr.slice(-1)[0], item]];\n    },\n    [] as Array<Array<T>>,\n  );\n}\n\nexport function zip<T, U>(a1: Array<T>, a2: Array<U>) {\n  const resultLength = Math.max(a1.length, a2.length);\n  return new Array(resultLength).fill([]).map((_val, idx) => [a1[idx], a2[idx]]);\n}\n\nexport function differenceBy<T>(a1: Array<T>, a2: Array<T>, by: (arg: T) => string) {\n  return a1.filter((c) => !a2.map((v) => by(v)).includes(by(c)));\n}\n","/**\n * Internal test function.\n *\n * @internal\n */\n\nimport { Participant, Track, TrackPublication } from 'livekit-client';\nimport type { UpdatableItem } from '../sorting/tile-array-update';\nimport type { TrackReference, TrackReferencePlaceholder } from './track-reference.types';\nimport { getTrackReferenceId } from './track-reference.utils';\n\n// Test function:\nexport const mockTrackReferencePlaceholder = (\n  id: string,\n  source: Track.Source,\n): TrackReferencePlaceholder => {\n  return { participant: new Participant(`${id}`, `${id}`), source };\n};\n\nexport const mockTrackReferencePublished = (id: string, source: Track.Source): TrackReference => {\n  const kind = [Track.Source.Camera, Track.Source.ScreenShare].includes(source)\n    ? Track.Kind.Video\n    : Track.Kind.Audio;\n  return {\n    participant: new Participant(`${id}`, `${id}`),\n    publication: new TrackPublication(kind, `${id}`, `${id}`),\n    source: source,\n  };\n};\n\ntype mockTrackReferenceSubscribedOptions = {\n  mockPublication?: boolean;\n  mockParticipant?: boolean;\n  mockIsLocal?: boolean;\n};\n\nexport const mockTrackReferenceSubscribed = (\n  id: string,\n  source: Track.Source,\n  options: mockTrackReferenceSubscribedOptions = {},\n): TrackReference => {\n  const kind = [Track.Source.Camera, Track.Source.ScreenShare].includes(source)\n    ? Track.Kind.Video\n    : Track.Kind.Audio;\n\n  const publication = new TrackPublication(kind, `${id}`, `${id}`);\n  // @ts-expect-error\n  publication.track = {};\n  return {\n    participant: options.mockParticipant\n      ? (mockParticipant(id, options.mockIsLocal ?? false) as Participant)\n      : new Participant(`${id}`, `${id}`),\n    publication: options.mockPublication\n      ? (mockTrackPublication(`publicationId(${id})`, kind, source) as TrackPublication)\n      : publication,\n    source,\n  };\n};\n\nconst mockTrackPublication = (\n  id: string,\n  kind: Track.Kind,\n  source: Track.Source,\n): Pick<TrackPublication, 'kind' | 'trackSid' | 'trackName' | 'source'> => {\n  return {\n    kind,\n    trackSid: id,\n    trackName: `name_${id}`,\n    source: source,\n  };\n};\n\nfunction mockParticipant(\n  id: string,\n  isLocal: boolean,\n): Pick<Participant, 'sid' | 'identity' | 'isLocal'> {\n  return {\n    sid: `${id}_sid`,\n    identity: `${id}`,\n    isLocal: isLocal,\n  };\n}\n\nexport function flatTrackReferenceArray<T extends UpdatableItem>(list: T[]): string[] {\n  return list.map((item) => {\n    if (typeof item === 'string' || typeof item === 'number') {\n      return `${item}`;\n    } else {\n      return getTrackReferenceId(item);\n    }\n  });\n}\n","import { differenceBy, chunk, zip } from '../helper/array-helper';\nimport { log } from '../logger';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\nimport {\n  getTrackReferenceId,\n  isPlaceholderReplacement,\n  isTrackReference,\n  isTrackReferencePlaceholder,\n} from '../track-reference';\nimport { flatTrackReferenceArray } from '../track-reference/test-utils';\n\ntype VisualChanges<T> = {\n  dropped: T[];\n  added: T[];\n};\n\nexport type UpdatableItem = TrackReferenceOrPlaceholder | number;\n\n/** Check to see if anything visually changes on the page. */\nexport function visualPageChange<T extends UpdatableItem>(state: T[], next: T[]): VisualChanges<T> {\n  return {\n    dropped: differenceBy(state, next, getTrackReferenceId),\n    added: differenceBy(next, state, getTrackReferenceId),\n  };\n}\n\nfunction listNeedsUpdating<T>(changes: VisualChanges<T>): boolean {\n  return changes.added.length !== 0 || changes.dropped.length !== 0;\n}\n\nexport function findIndex<T extends UpdatableItem>(\n  trackReference: T,\n  trackReferences: T[],\n): number {\n  const indexToReplace = trackReferences.findIndex(\n    (trackReference_) =>\n      getTrackReferenceId(trackReference_) === getTrackReferenceId(trackReference),\n  );\n  if (indexToReplace === -1) {\n    throw new Error(\n      `Element not part of the array: ${getTrackReferenceId(\n        trackReference,\n      )} not in ${flatTrackReferenceArray(trackReferences)}`,\n    );\n  }\n  return indexToReplace;\n}\n\n/** Swap items in the complete list of all elements */\nexport function swapItems<T extends UpdatableItem>(\n  moveForward: T,\n  moveBack: T,\n  trackReferences: T[],\n): T[] {\n  const indexToReplace = findIndex(moveForward, trackReferences);\n  const indexReplaceWith = findIndex(moveBack, trackReferences);\n\n  trackReferences.splice(indexToReplace, 1, moveBack);\n  trackReferences.splice(indexReplaceWith, 1, moveForward);\n\n  return trackReferences;\n}\n\nexport function dropItem<T extends UpdatableItem>(itemToDrop: T, list: T[]): T[] {\n  const indexOfElementToDrop = findIndex(itemToDrop, list);\n  // const indexOfElementToDrop = list.findIndex((item) => item === itemToDrop, list);\n  list.splice(indexOfElementToDrop, 1);\n  return list;\n}\n\nfunction addItem<T extends UpdatableItem>(itemToAdd: T, list: T[]): T[] {\n  return [...list, itemToAdd];\n}\n\nexport function divideIntoPages<T>(list: T[], maxElementsOnPage: number): Array<T[]> {\n  const pages = chunk(list, maxElementsOnPage);\n  return pages;\n}\n\n/** Divide the list of elements into pages and and check if pages need updating. */\nexport function updatePages<T extends UpdatableItem>(\n  currentList: T[],\n  nextList: T[],\n  maxItemsOnPage: number,\n): T[] {\n  let updatedList: T[] = refreshList(currentList, nextList);\n\n  if (updatedList.length < nextList.length) {\n    // Items got added: Find newly added items and add them to the end of the list.\n    const addedItems = differenceBy(nextList, updatedList, getTrackReferenceId);\n    updatedList = [...updatedList, ...addedItems];\n  }\n  const currentPages = divideIntoPages(updatedList, maxItemsOnPage);\n  const nextPages = divideIntoPages(nextList, maxItemsOnPage);\n\n  zip(currentPages, nextPages).forEach(([currentPage, nextPage], pageIndex) => {\n    if (currentPage && nextPage) {\n      // 1) Identify  missing tile.\n      const updatedPage = divideIntoPages(updatedList, maxItemsOnPage)[pageIndex];\n      const changes = visualPageChange(updatedPage, nextPage);\n\n      if (listNeedsUpdating(changes)) {\n        log.debug(\n          `Detected visual changes on page: ${pageIndex}, current: ${flatTrackReferenceArray(\n            currentPage,\n          )}, next: ${flatTrackReferenceArray(nextPage)}`,\n          { changes },\n        );\n        // ## Swap Items\n        if (changes.added.length === changes.dropped.length) {\n          zip(changes.added, changes.dropped).forEach(([added, dropped]) => {\n            if (added && dropped) {\n              updatedList = swapItems<T>(added, dropped, updatedList);\n            } else {\n              throw new Error(\n                `For a swap action we need a addition and a removal one is missing: ${added}, ${dropped}`,\n              );\n            }\n          });\n        }\n        // ## Handle Drop Items\n        if (changes.added.length === 0 && changes.dropped.length > 0) {\n          changes.dropped.forEach((item) => {\n            updatedList = dropItem<T>(item, updatedList);\n          });\n        }\n        // ## Handle Item added\n        if (changes.added.length > 0 && changes.dropped.length === 0) {\n          changes.added.forEach((item) => {\n            updatedList = addItem<T>(item, updatedList);\n          });\n        }\n      }\n    }\n  });\n\n  if (updatedList.length > nextList.length) {\n    // Items got removed: Find items that got completely removed from the list.\n    const missingItems = differenceBy(updatedList, nextList, getTrackReferenceId);\n    updatedList = updatedList.filter(\n      (item) => !missingItems.map(getTrackReferenceId).includes(getTrackReferenceId(item)),\n    );\n  }\n\n  return updatedList;\n}\n\n/**\n * Update the current list with the items from the next list whenever the item ids are the same\n * or the current item is a placeholder and we find a track reference in the next list\n * to replace the placeholder with.\n * @remarks\n * This is needed because `TrackReference`s can change their internal state while keeping the same id.\n */\nfunction refreshList<T extends UpdatableItem>(currentList: T[], nextList: T[]): T[] {\n  return currentList.map((currentItem) => {\n    const updateForCurrentItem = nextList.find(\n      (newItem_) =>\n        // If the IDs match or ..\n        getTrackReferenceId(currentItem) === getTrackReferenceId(newItem_) ||\n        // ... if the current item is a placeholder and the new item is the track reference can replace it.\n        (typeof currentItem !== 'number' &&\n          isTrackReferencePlaceholder(currentItem) &&\n          isTrackReference(newItem_) &&\n          isPlaceholderReplacement(currentItem, newItem_)),\n    );\n    return updateForCurrentItem ?? currentItem;\n  });\n}\n","import type {\n  AudioCaptureOptions,\n  LocalParticipant,\n  Room,\n  ScreenShareCaptureOptions,\n  VideoCaptureOptions,\n} from 'livekit-client';\nimport { Track } from 'livekit-client';\nimport type { Observable } from 'rxjs';\nimport { Subject, map, startWith } from 'rxjs';\nimport { observeParticipantMedia } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\n\nexport type CaptureOptionsBySource<T extends ToggleSource> = T extends Track.Source.Camera\n  ? VideoCaptureOptions\n  : T extends Track.Source.Microphone\n  ? AudioCaptureOptions\n  : T extends Track.Source.ScreenShare\n  ? ScreenShareCaptureOptions\n  : never;\n\nexport type MediaToggleType<T extends ToggleSource> = {\n  pendingObserver: Observable<boolean>;\n  toggle: (forceState?: boolean, captureOptions?: CaptureOptionsBySource<T>) => Promise<void>;\n  className: string;\n  enabledObserver: Observable<boolean>;\n};\n\nexport type ToggleSource = Exclude<\n  Track.Source,\n  Track.Source.ScreenShareAudio | Track.Source.Unknown\n>;\n\nexport function setupMediaToggle<T extends ToggleSource>(\n  source: T,\n  room: Room,\n  options?: CaptureOptionsBySource<T>,\n): MediaToggleType<T> {\n  const { localParticipant } = room;\n\n  const getSourceEnabled = (source: ToggleSource, localParticipant: LocalParticipant) => {\n    let isEnabled = false;\n    switch (source) {\n      case Track.Source.Camera:\n        isEnabled = localParticipant.isCameraEnabled;\n        break;\n      case Track.Source.Microphone:\n        isEnabled = localParticipant.isMicrophoneEnabled;\n        break;\n      case Track.Source.ScreenShare:\n        isEnabled = localParticipant.isScreenShareEnabled;\n        break;\n      default:\n        break;\n    }\n    return isEnabled;\n  };\n\n  const enabledObserver = observeParticipantMedia(localParticipant).pipe(\n    map((media) => {\n      return getSourceEnabled(source, media.participant as LocalParticipant);\n    }),\n    startWith(getSourceEnabled(source, localParticipant)),\n  );\n\n  const pendingSubject = new Subject<boolean>();\n  const toggle = async (forceState?: boolean, captureOptions?: CaptureOptionsBySource<T>) => {\n    try {\n      captureOptions ??= options;\n      // trigger observable update\n      pendingSubject.next(true);\n      switch (source) {\n        case Track.Source.Camera:\n          await localParticipant.setCameraEnabled(\n            forceState ?? !localParticipant.isCameraEnabled,\n            captureOptions as VideoCaptureOptions,\n          );\n          break;\n        case Track.Source.Microphone:\n          await localParticipant.setMicrophoneEnabled(\n            forceState ?? !localParticipant.isMicrophoneEnabled,\n            captureOptions as AudioCaptureOptions,\n          );\n          break;\n        case Track.Source.ScreenShare:\n          await localParticipant.setScreenShareEnabled(\n            forceState ?? !localParticipant.isScreenShareEnabled,\n            captureOptions as ScreenShareCaptureOptions,\n          );\n          break;\n        default:\n          break;\n      }\n    } finally {\n      pendingSubject.next(false);\n      // trigger observable update\n    }\n  };\n\n  const className: string = prefixClass('button');\n  return {\n    className,\n    toggle,\n    enabledObserver,\n    pendingObserver: pendingSubject.asObservable(),\n  };\n}\n\nexport function setupManualToggle() {\n  let state = false;\n\n  const enabledSubject = new Subject<boolean>();\n\n  const pendingSubject = new Subject<boolean>();\n\n  const toggle = async (forceState?: boolean) => {\n    pendingSubject.next(true);\n    state = forceState ?? !state;\n    enabledSubject.next(state);\n    pendingSubject.next(false);\n  };\n  const className: string = prefixClass('button');\n  return {\n    className,\n    toggle,\n    enabledObserver: enabledSubject.asObservable(),\n    pendingObserver: pendingSubject.asObservable(),\n  };\n}\n","import type { Participant, RemoteParticipant, Room, TrackPublication } from 'livekit-client';\nimport { ParticipantEvent, RoomEvent, Track } from 'livekit-client';\nimport type { Subscriber } from 'rxjs';\nimport { map, switchMap, Observable, startWith } from 'rxjs';\nimport { observeRoomEvents } from './room';\nimport type { ParticipantEventCallbacks } from 'livekit-client/dist/src/room/participant/Participant';\nimport { allParticipantEvents, allParticipantRoomEvents } from '../helper/eventGroups';\nimport type { TrackIdentifier } from '../types';\nimport { getTrackByIdentifier } from '../components/mediaTrack';\nimport { TrackReferenceOrPlaceholder } from '../track-reference';\n\nexport function observeParticipantEvents<T extends Participant>(\n  participant: T,\n  ...events: ParticipantEvent[]\n) {\n  const observable = new Observable<T>((subscribe) => {\n    const onParticipantUpdate = () => {\n      subscribe.next(participant);\n    };\n\n    events.forEach((evt) => {\n      participant.on(evt as keyof ParticipantEventCallbacks, onParticipantUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        participant.off(evt as keyof ParticipantEventCallbacks, onParticipantUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(participant));\n\n  return observable;\n}\n\nexport interface ParticipantMedia<T extends Participant = Participant> {\n  isCameraEnabled: boolean;\n  isMicrophoneEnabled: boolean;\n  isScreenShareEnabled: boolean;\n  microphoneTrack?: TrackPublication;\n  cameraTrack?: TrackPublication;\n  participant: T;\n}\n\nexport function observeParticipantMedia<T extends Participant>(participant: T) {\n  const participantObserver = observeParticipantEvents(\n    participant,\n    ParticipantEvent.TrackMuted,\n    ParticipantEvent.TrackUnmuted,\n    ParticipantEvent.ParticipantPermissionsChanged,\n    // ParticipantEvent.IsSpeakingChanged,\n    ParticipantEvent.TrackPublished,\n    ParticipantEvent.TrackUnpublished,\n    ParticipantEvent.LocalTrackPublished,\n    ParticipantEvent.LocalTrackUnpublished,\n    ParticipantEvent.MediaDevicesError,\n    ParticipantEvent.TrackSubscriptionStatusChanged,\n    // ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(\n    map((p) => {\n      const { isMicrophoneEnabled, isCameraEnabled, isScreenShareEnabled } = p;\n      const microphoneTrack = p.getTrack(Track.Source.Microphone);\n      const cameraTrack = p.getTrack(Track.Source.Camera);\n      const participantMedia: ParticipantMedia<T> = {\n        isCameraEnabled,\n        isMicrophoneEnabled,\n        isScreenShareEnabled,\n        cameraTrack,\n        microphoneTrack,\n        participant: p,\n      };\n      return participantMedia;\n    }),\n  );\n\n  return participantObserver;\n}\n\nexport function createTrackObserver(participant: Participant, options: TrackIdentifier) {\n  return observeParticipantMedia(participant).pipe(\n    map(() => {\n      return { publication: getTrackByIdentifier(options) };\n    }),\n  );\n}\n\nexport function participantInfoObserver(participant: Participant) {\n  const observer = observeParticipantEvents(\n    participant,\n    ParticipantEvent.ParticipantMetadataChanged,\n    // ParticipantEvent.LocalTrackPublished,\n  ).pipe(\n    map(({ name, identity, metadata }) => {\n      return {\n        name,\n        identity,\n        metadata,\n      };\n    }),\n    startWith({\n      name: participant.name,\n      identity: participant.identity,\n      metadata: participant.metadata,\n    }),\n  );\n  return observer;\n}\n\nexport function createConnectionQualityObserver(participant: Participant) {\n  const observer = participantEventSelector(\n    participant,\n    ParticipantEvent.ConnectionQualityChanged,\n  ).pipe(\n    map(([quality]) => quality),\n    startWith(participant.connectionQuality),\n  );\n  return observer;\n}\n\nexport function participantEventSelector<T extends ParticipantEvent>(\n  participant: Participant,\n  event: T,\n) {\n  const observable = new Observable<\n    Parameters<ParticipantEventCallbacks[Extract<T, keyof ParticipantEventCallbacks>]>\n  >((subscribe) => {\n    const update = (\n      ...params: Parameters<ParticipantEventCallbacks[Extract<T, keyof ParticipantEventCallbacks>]>\n    ) => {\n      subscribe.next(params);\n    };\n    // @ts-expect-error not a perfect overlap between ParticipantEvent and keyof ParticipantEventCallbacks\n    participant.on(event, update);\n\n    const unsubscribe = () => {\n      // @ts-expect-error not a perfect overlap between ParticipantEvent and keyof ParticipantEventCallbacks\n      participant.off(event, update);\n    };\n    return unsubscribe;\n  });\n\n  return observable;\n}\n\nexport function mutedObserver(trackRef: TrackReferenceOrPlaceholder) {\n  return observeParticipantEvents(\n    trackRef.participant,\n    ParticipantEvent.TrackMuted,\n    ParticipantEvent.TrackUnmuted,\n    ParticipantEvent.TrackSubscribed,\n    ParticipantEvent.TrackUnsubscribed,\n    ParticipantEvent.LocalTrackPublished,\n    ParticipantEvent.LocalTrackUnpublished,\n  ).pipe(\n    map((participant) => {\n      const pub = trackRef.publication ?? participant.getTrack(trackRef.source);\n      return pub?.isMuted ?? true;\n    }),\n    startWith(\n      trackRef.publication?.isMuted ??\n        trackRef.participant.getTrack(trackRef.source)?.isMuted ??\n        true,\n    ),\n  );\n}\n\nexport function createIsSpeakingObserver(participant: Participant) {\n  return participantEventSelector(participant, ParticipantEvent.IsSpeakingChanged).pipe(\n    map(([isSpeaking]) => isSpeaking),\n  );\n}\n\ntype ConnectedParticipantsObserverOptions = {\n  additionalRoomEvents?: RoomEvent[];\n};\n\nexport function connectedParticipantsObserver(\n  room: Room,\n  options: ConnectedParticipantsObserverOptions = {},\n) {\n  let subscriber: Subscriber<RemoteParticipant[]> | undefined;\n\n  const observable = new Observable<RemoteParticipant[]>((sub) => {\n    subscriber = sub;\n    return () => listener.unsubscribe();\n  }).pipe(startWith(Array.from(room.participants.values())));\n\n  const additionalRoomEvents = options.additionalRoomEvents ?? allParticipantRoomEvents;\n\n  const roomEvents = Array.from(\n    new Set([\n      RoomEvent.ParticipantConnected,\n      RoomEvent.ParticipantDisconnected,\n      RoomEvent.ConnectionStateChanged,\n      ...additionalRoomEvents,\n    ]),\n  );\n\n  const listener = observeRoomEvents(room, ...roomEvents).subscribe(\n    (r) => subscriber?.next(Array.from(r.participants.values())),\n  );\n  if (room.participants.size > 0) {\n    subscriber?.next(Array.from(room.participants.values()));\n  }\n  return observable;\n}\n\nexport type ConnectedParticipantObserverOptions = {\n  additionalEvents?: ParticipantEvent[];\n};\n\nexport function connectedParticipantObserver(\n  room: Room,\n  identity: string,\n  options: ConnectedParticipantObserverOptions = {},\n) {\n  const additionalEvents = options.additionalEvents ?? allParticipantEvents;\n  const observable = observeRoomEvents(\n    room,\n    RoomEvent.ParticipantConnected,\n    RoomEvent.ParticipantDisconnected,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(\n    switchMap((r) => {\n      const participant = r.getParticipantByIdentity(identity) as RemoteParticipant | undefined;\n      if (participant) {\n        return observeParticipantEvents(participant, ...additionalEvents);\n      } else {\n        return new Observable<undefined>((subscribe) => subscribe.next(undefined));\n      }\n    }),\n    startWith(room.getParticipantByIdentity(identity) as RemoteParticipant | undefined),\n  );\n\n  return observable;\n}\n\nexport function participantPermissionObserver(participant: Participant) {\n  const observer = participantEventSelector(\n    participant,\n    ParticipantEvent.ParticipantPermissionsChanged,\n  ).pipe(\n    map(() => participant.permissions),\n    startWith(participant.permissions),\n  );\n  return observer;\n}\n","import type { Subscriber, Subscription } from 'rxjs';\nimport { Subject, map, Observable, startWith, finalize, filter, concat } from 'rxjs';\nimport type { Participant, TrackPublication } from 'livekit-client';\nimport { LocalParticipant, Room, RoomEvent, Track } from 'livekit-client';\nimport type { RoomEventCallbacks } from 'livekit-client/dist/src/room/Room';\nimport { log } from '../logger';\nexport function observeRoomEvents(room: Room, ...events: RoomEvent[]): Observable<Room> {\n  const observable = new Observable<Room>((subscribe) => {\n    const onRoomUpdate = () => {\n      subscribe.next(room);\n    };\n\n    events.forEach((evt) => {\n      room.on(evt, onRoomUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        room.off(evt, onRoomUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(room));\n\n  return observable;\n}\n\nexport function roomEventSelector<T extends RoomEvent>(room: Room, event: T) {\n  const observable = new Observable<Parameters<RoomEventCallbacks[T]>>((subscribe) => {\n    const update = (...params: Parameters<RoomEventCallbacks[T]>) => {\n      subscribe.next(params);\n    };\n    room.on(event as keyof RoomEventCallbacks, update);\n\n    const unsubscribe = () => {\n      room.off(event as keyof RoomEventCallbacks, update);\n    };\n    return unsubscribe;\n  });\n\n  return observable;\n}\n\nexport function roomObserver(room: Room) {\n  const observable = observeRoomEvents(\n    room,\n    RoomEvent.ParticipantConnected,\n    RoomEvent.ParticipantDisconnected,\n    RoomEvent.ActiveSpeakersChanged,\n    RoomEvent.TrackSubscribed,\n    RoomEvent.TrackUnsubscribed,\n    RoomEvent.LocalTrackPublished,\n    RoomEvent.LocalTrackUnpublished,\n    RoomEvent.AudioPlaybackStatusChanged,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(startWith(room));\n\n  return observable;\n}\n\nexport function connectionStateObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.ConnectionStateChanged).pipe(\n    map(([connectionState]) => connectionState),\n    startWith(room.state),\n  );\n}\nexport type ScreenShareTrackMap = Array<{\n  participant: Participant;\n  tracks: Array<TrackPublication>;\n}>;\n\nexport function screenShareObserver(room: Room) {\n  let screenShareSubscriber: Subscriber<ScreenShareTrackMap>;\n  const observers: Array<Subscription> = [];\n\n  const observable = new Observable<ScreenShareTrackMap>((subscriber) => {\n    screenShareSubscriber = subscriber;\n    return () => {\n      observers.forEach((observer) => {\n        observer.unsubscribe();\n      });\n    };\n  });\n  const screenShareTracks: ScreenShareTrackMap = [];\n\n  const handleSub = (publication: TrackPublication, participant: Participant) => {\n    if (\n      publication.source !== Track.Source.ScreenShare &&\n      publication.source !== Track.Source.ScreenShareAudio\n    ) {\n      return;\n    }\n    let trackMap = screenShareTracks.find((tr) => tr.participant.identity === participant.identity);\n    const getScreenShareTracks = (participant: Participant) => {\n      return participant\n        .getTracks()\n        .filter(\n          (track) =>\n            (track.source === Track.Source.ScreenShare ||\n              track.source === Track.Source.ScreenShareAudio) &&\n            track.track,\n        );\n    };\n    if (!trackMap) {\n      trackMap = {\n        participant,\n        tracks: getScreenShareTracks(participant),\n      };\n    } else {\n      const index = screenShareTracks.indexOf(trackMap);\n      screenShareTracks.splice(index, 1);\n      trackMap.tracks = getScreenShareTracks(participant);\n    }\n    if (trackMap.tracks.length > 0) {\n      screenShareTracks.push(trackMap);\n    }\n\n    screenShareSubscriber.next(screenShareTracks);\n  };\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackSubscribed).subscribe(([, ...args]) =>\n      handleSub(...args),\n    ),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackUnsubscribed).subscribe(([, ...args]) =>\n      handleSub(...args),\n    ),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.LocalTrackPublished).subscribe((args) => handleSub(...args)),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.LocalTrackUnpublished).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackMuted).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  observers.push(\n    roomEventSelector(room, RoomEvent.TrackUnmuted).subscribe((args) => {\n      handleSub(...args);\n    }),\n  );\n  setTimeout(() => {\n    // TODO find way to avoid this timeout\n    for (const p of room.participants.values()) {\n      p.getTracks().forEach((track) => {\n        handleSub(track, p);\n      });\n    }\n  }, 1);\n\n  return observable;\n}\n\nexport function roomInfoObserver(room: Room) {\n  const observer = observeRoomEvents(\n    room,\n    RoomEvent.RoomMetadataChanged,\n    RoomEvent.ConnectionStateChanged,\n  ).pipe(\n    map((r) => {\n      return { name: r.name, metadata: r.metadata };\n    }),\n  );\n  return observer;\n}\n\nexport function activeSpeakerObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.ActiveSpeakersChanged).pipe(\n    map(([speakers]) => speakers),\n  );\n}\n\nexport function createMediaDeviceObserver(\n  kind?: MediaDeviceKind,\n  onError?: (e: Error) => void,\n  requestPermissions = true,\n) {\n  const onDeviceChange = async () => {\n    try {\n      const newDevices = await Room.getLocalDevices(kind, requestPermissions);\n      deviceSubject.next(newDevices);\n    } catch (e: any) {\n      onError?.(e);\n    }\n  };\n  const deviceSubject = new Subject<MediaDeviceInfo[]>();\n\n  const observable = deviceSubject.pipe(\n    finalize(() => {\n      navigator?.mediaDevices?.removeEventListener('devicechange', onDeviceChange);\n    }),\n  );\n\n  if (typeof window !== 'undefined') {\n    if (!window.isSecureContext) {\n      throw new Error(\n        `Accessing media devices is available only in secure contexts (HTTPS and localhost), in some or all supporting browsers. See: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/mediaDevices`,\n      );\n    }\n    navigator?.mediaDevices?.addEventListener('devicechange', onDeviceChange);\n  }\n  // because we rely on an async function, concat the promise to retrieve the initial values with the observable\n  return concat(\n    Room.getLocalDevices(kind, requestPermissions).catch((e) => onError?.(e)),\n    observable,\n  );\n}\n\nexport function createDataObserver(room: Room) {\n  return roomEventSelector(room, RoomEvent.DataReceived);\n}\n\nexport function roomAudioPlaybackAllowedObservable(room: Room) {\n  const observable = observeRoomEvents(room, RoomEvent.AudioPlaybackStatusChanged).pipe(\n    map((room) => {\n      return { canPlayAudio: room.canPlaybackAudio };\n    }),\n  );\n  return observable;\n}\n\nexport function roomVideoPlaybackAllowedObservable(room: Room) {\n  const observable = observeRoomEvents(room, RoomEvent.VideoPlaybackStatusChanged).pipe(\n    map((room) => {\n      return { canPlayVideo: room.canPlaybackVideo };\n    }),\n  );\n  return observable;\n}\n\nexport function createActiveDeviceObservable(room: Room, kind: MediaDeviceKind) {\n  return roomEventSelector(room, RoomEvent.ActiveDeviceChanged).pipe(\n    filter(([kindOfDevice]) => kindOfDevice === kind),\n    map(([kind, deviceId]) => {\n      log.debug('activeDeviceObservable | RoomEvent.ActiveDeviceChanged', { kind, deviceId });\n      return deviceId;\n    }),\n    startWith(room.getActiveDevice(kind)),\n  );\n}\n\nexport function encryptionStatusObservable(room: Room, participant: Participant) {\n  return roomEventSelector(room, RoomEvent.ParticipantEncryptionStatusChanged).pipe(\n    filter(\n      ([, p]) =>\n        participant.identity === p?.identity ||\n        (!p && participant.identity === room.localParticipant.identity),\n    ),\n    map(([encrypted]) => encrypted),\n    startWith(\n      participant instanceof LocalParticipant ? participant.isE2EEEnabled : participant.isEncrypted,\n    ),\n  );\n}\n","import { Track } from 'livekit-client';\nimport { map, startWith } from 'rxjs';\nimport { observeParticipantMedia } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\nimport { isTrackReference } from '../track-reference/track-reference.types';\nimport type { TrackIdentifier } from '../types';\n\nexport function setupMediaTrack(trackIdentifier: TrackIdentifier) {\n  const initialPub = getTrackByIdentifier(trackIdentifier);\n  const trackObserver = observeParticipantMedia(trackIdentifier.participant).pipe(\n    map(() => {\n      return getTrackByIdentifier(trackIdentifier);\n    }),\n    startWith(initialPub),\n  );\n  const className: string = prefixClass(\n    trackIdentifier.source === Track.Source.Camera ||\n      trackIdentifier.source === Track.Source.ScreenShare\n      ? 'participant-media-video'\n      : 'participant-media-audio',\n  );\n  return { className, trackObserver };\n}\n\nexport function getTrackByIdentifier(options: TrackIdentifier) {\n  if (isTrackReference(options)) {\n    return options.publication;\n  } else {\n    const { source, name, participant } = options;\n    if (source && name) {\n      return participant.getTracks().find((pub) => pub.source === source && pub.trackName === name);\n    } else if (name) {\n      return participant.getTrackByName(name);\n    } else if (source) {\n      return participant.getTrack(source);\n    } else {\n      throw new Error('At least one of source and name needs to be defined');\n    }\n  }\n}\n","import type { UnprefixedClassNames as ComponentNoPrefixClasses } from '@livekit/components-styles/dist/types_unprefixed/index.scss';\nimport type { UnprefixedClassNames as PrefabNoPrefixClasses } from '@livekit/components-styles/dist/types_unprefixed/prefabs/index.scss';\nimport { cssPrefix } from './../constants';\n\ntype UnprefixedClassNames = ComponentNoPrefixClasses | PrefabNoPrefixClasses;\n\n/**\n * This function is a type safe way to add a prefix to a HTML class attribute.\n * Only classes defined in the styles module are valid, any other class produces a ts error.\n * @internal\n */\nexport function prefixClass<T extends UnprefixedClassNames>(unprefixedClassName: T) {\n  return `${cssPrefix}-${unprefixedClassName}` as const;\n}\n","import {\n  Track,\n  type LocalAudioTrack,\n  type LocalVideoTrack,\n  type Room,\n  type LocalTrack,\n} from 'livekit-client';\nimport { BehaviorSubject } from 'rxjs';\nimport { log } from '../logger';\nimport { prefixClass } from '../styles-interface';\nimport { createActiveDeviceObservable } from '../observables/room';\n\nexport type SetMediaDeviceOptions = {\n  /**\n   *  If true, adds an `exact` constraint to the getUserMedia request.\n   *  The request will fail if this option is true and the device specified is not actually available\n   */\n  exact?: boolean;\n};\n\nexport function setupDeviceSelector(\n  kind: MediaDeviceKind,\n  room?: Room,\n  localTrack?: LocalAudioTrack | LocalVideoTrack,\n) {\n  const activeDeviceSubject = new BehaviorSubject<string | undefined>(undefined);\n\n  const activeDeviceObservable = room\n    ? createActiveDeviceObservable(room, kind)\n    : activeDeviceSubject.asObservable();\n\n  const setActiveMediaDevice = async (id: string, options: SetMediaDeviceOptions = {}) => {\n    if (room) {\n      log.debug(`Switching active device of kind \"${kind}\" with id ${id}.`);\n      await room.switchActiveDevice(kind, id, options.exact);\n      const actualDeviceId: string | undefined = room.getActiveDevice(kind) ?? id;\n      if (actualDeviceId !== id && id !== 'default') {\n        log.info(\n          `We tried to select the device with id (${id}), but the browser decided to select the device with id (${actualDeviceId}) instead.`,\n        );\n      }\n      let targetTrack: LocalTrack | undefined = undefined;\n      if (kind === 'audioinput')\n        targetTrack = room.localParticipant.getTrack(Track.Source.Microphone)?.track;\n      else if (kind === 'videoinput') {\n        targetTrack = room.localParticipant.getTrack(Track.Source.Camera)?.track;\n      }\n      const useDefault =\n        (id === 'default' && !targetTrack) ||\n        (id === 'default' && targetTrack?.mediaStreamTrack.label.startsWith('Default'));\n      activeDeviceSubject.next(useDefault ? id : actualDeviceId);\n    } else if (localTrack) {\n      await localTrack.setDeviceId(options.exact ? { exact: id } : id);\n      const actualId = await localTrack.getDeviceId();\n      activeDeviceSubject.next(\n        id === 'default' && localTrack.mediaStreamTrack.label.startsWith('Default') ? id : actualId,\n      );\n    } else if (activeDeviceSubject.value !== id) {\n      log.warn(\n        'device switch skipped, please provide either a room or a local track to switch on. ',\n      );\n      activeDeviceSubject.next(id);\n    }\n  };\n  const className: string = prefixClass('media-device-select');\n  return {\n    className,\n    activeDeviceObservable,\n    setActiveMediaDevice,\n  };\n}\n","import type { Room } from 'livekit-client';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupDisconnectButton(room: Room) {\n  const disconnect = (stopTracks?: boolean) => {\n    room.disconnect(stopTracks);\n  };\n  const className: string = prefixClass('disconnect-button');\n  return { className, disconnect };\n}\n","import type { Participant } from 'livekit-client';\nimport { createConnectionQualityObserver } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupConnectionQualityIndicator(participant: Participant) {\n  const className = prefixClass('connection-quality');\n  const connectionQualityObserver = createConnectionQualityObserver(participant);\n  return { className, connectionQualityObserver };\n}\n","import type { Styles } from '@livekit/components-styles/dist/types_unprefixed/index.scss';\nimport { Track } from 'livekit-client';\nimport { mutedObserver } from '../observables/participant';\nimport { prefixClass } from '../styles-interface';\nimport type { TrackReferenceOrPlaceholder } from '../track-reference';\n\nexport function setupTrackMutedIndicator(trackRef: TrackReferenceOrPlaceholder) {\n  let classForSource: keyof Styles = 'track-muted-indicator-camera';\n  switch (trackRef.source) {\n    case Track.Source.Camera:\n      classForSource = 'track-muted-indicator-camera';\n      break;\n    case Track.Source.Microphone:\n      classForSource = 'track-muted-indicator-microphone';\n      break;\n\n    default:\n      break;\n  }\n  const className: string = prefixClass(classForSource);\n  const mediaMutedObserver = mutedObserver(trackRef);\n\n  return { className, mediaMutedObserver };\n}\n","import type { Participant } from 'livekit-client';\nimport { participantInfoObserver } from '../observables/participant';\n\nexport function setupParticipantName(participant: Participant) {\n  const infoObserver = participantInfoObserver(participant);\n  return { className: 'lk-participant-name', infoObserver };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupParticipantTile() {\n  const className: string = prefixClass('participant-tile');\n  return {\n    className,\n  };\n}\n","/* eslint-disable camelcase */\nimport type { Participant, Room } from 'livekit-client';\nimport { DataPacket_Kind, RoomEvent } from 'livekit-client';\nimport { BehaviorSubject, Subject, scan, map, takeUntil } from 'rxjs';\nimport { DataTopic, sendMessage, setupDataMessageHandler } from '../observables/dataChannel';\n\n/** @public */\nexport interface ChatMessage {\n  timestamp: number;\n  message: string;\n}\n\n/** @public */\nexport interface ReceivedChatMessage extends ChatMessage {\n  from?: Participant;\n}\n\n/** @public */\nexport type MessageEncoder = (message: ChatMessage) => Uint8Array;\n/** @public */\nexport type MessageDecoder = (message: Uint8Array) => ReceivedChatMessage;\n/** @public */\nexport type ChatOptions = {\n  messageEncoder?: (message: ChatMessage) => Uint8Array;\n  messageDecoder?: (message: Uint8Array) => ReceivedChatMessage;\n  channelTopic?: string;\n};\n\ntype RawMessage = {\n  payload: Uint8Array;\n  topic: string | undefined;\n  from: Participant | undefined;\n};\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\n\nconst topicSubjectMap: Map<Room, Map<string, Subject<RawMessage>>> = new Map();\n\nconst encode = (message: ChatMessage) =>\n  encoder.encode(JSON.stringify({ message: message.message, timestamp: message.timestamp }));\n\nconst decode = (message: Uint8Array) => JSON.parse(decoder.decode(message)) as ReceivedChatMessage;\n\nexport function setupChat(room: Room, options?: ChatOptions) {\n  const onDestroyObservable = new Subject<void>();\n\n  const { messageDecoder, messageEncoder, channelTopic } = options ?? {};\n\n  const topic = channelTopic ?? DataTopic.CHAT;\n\n  let needsSetup = false;\n  if (!topicSubjectMap.has(room)) {\n    needsSetup = true;\n  }\n  const topicMap = topicSubjectMap.get(room) ?? new Map<string, Subject<RawMessage>>();\n  const messageSubject = topicMap.get(topic) ?? new Subject<RawMessage>();\n  topicMap.set(topic, messageSubject);\n  topicSubjectMap.set(room, topicMap);\n\n  if (needsSetup) {\n    /** Subscribe to all appropriate messages sent over the wire. */\n    const { messageObservable } = setupDataMessageHandler(room, topic);\n    messageObservable.pipe(takeUntil(onDestroyObservable)).subscribe(messageSubject);\n  }\n\n  const finalMessageDecoder = messageDecoder ?? decode;\n\n  /** Build up the message array over time. */\n  const messagesObservable = messageSubject.pipe(\n    map((msg) => {\n      const parsedMessage = finalMessageDecoder(msg.payload);\n      const newMessage: ReceivedChatMessage = { ...parsedMessage, from: msg.from };\n      return newMessage;\n    }),\n    scan<ReceivedChatMessage, ReceivedChatMessage[]>((acc, value) => [...acc, value], []),\n    takeUntil(onDestroyObservable),\n  );\n\n  const isSending$ = new BehaviorSubject<boolean>(false);\n\n  const finalMessageEncoder = messageEncoder ?? encode;\n\n  const send = async (message: string) => {\n    const timestamp = Date.now();\n    const encodedMsg = finalMessageEncoder({ message, timestamp });\n    isSending$.next(true);\n    try {\n      await sendMessage(room.localParticipant, encodedMsg, topic, {\n        kind: DataPacket_Kind.RELIABLE,\n      });\n      messageSubject.next({\n        payload: encodedMsg,\n        topic: topic,\n        from: room.localParticipant,\n      });\n    } finally {\n      isSending$.next(false);\n    }\n  };\n\n  function destroy() {\n    onDestroyObservable.next();\n    onDestroyObservable.complete();\n    topicSubjectMap.clear();\n  }\n  room.once(RoomEvent.Disconnected, destroy);\n\n  return { messageObservable: messagesObservable, isSendingObservable: isSending$, send };\n}\n","import type { LocalParticipant, Participant, Room } from 'livekit-client';\nimport { DataPacket_Kind } from 'livekit-client';\nimport type { Subscriber } from 'rxjs';\nimport { Observable, filter, map } from 'rxjs';\nimport { createDataObserver } from './room';\n\nexport const DataTopic = {\n  CHAT: 'lk-chat-topic',\n} as const;\n\nexport type DataSendOptions = {\n  kind?: DataPacket_Kind;\n  destination?: string[];\n};\n\n/** Publish data from the LocalParticipant. */\nexport async function sendMessage(\n  localParticipant: LocalParticipant,\n  payload: Uint8Array,\n  topic?: string,\n  options: DataSendOptions = {},\n) {\n  const { kind, destination } = options;\n\n  await localParticipant.publishData(payload, kind ?? DataPacket_Kind.RELIABLE, {\n    destination,\n    topic,\n  });\n}\n\nexport interface BaseDataMessage<T extends string | undefined> {\n  topic?: T;\n  payload: Uint8Array;\n}\n\nexport interface ReceivedDataMessage<T extends string | undefined = string>\n  extends BaseDataMessage<T> {\n  from?: Participant;\n}\n\nexport function setupDataMessageHandler<T extends string>(\n  room: Room,\n  topic?: T,\n  onMessage?: (msg: ReceivedDataMessage<T>) => void,\n) {\n  /** Setup a Observable that returns all data messages belonging to a topic. */\n  const messageObservable = createDataObserver(room).pipe(\n    filter(([, , , messageTopic]) => topic === undefined || messageTopic === topic),\n    map(([payload, participant, , messageTopic]) => {\n      const msg = {\n        payload,\n        topic: messageTopic as T,\n        from: participant,\n      } satisfies ReceivedDataMessage<T>;\n      onMessage?.(msg);\n      return msg;\n    }),\n  );\n\n  let isSendingSubscriber: Subscriber<boolean>;\n  const isSendingObservable = new Observable<boolean>((subscriber) => {\n    isSendingSubscriber = subscriber;\n  });\n\n  const send = async (payload: Uint8Array, options: DataSendOptions = {}) => {\n    isSendingSubscriber.next(true);\n    try {\n      await sendMessage(room.localParticipant, payload, topic, options);\n    } finally {\n      isSendingSubscriber.next(false);\n    }\n  };\n\n  return { messageObservable, isSendingObservable, send };\n}\n","import type { Room } from 'livekit-client';\nimport { log } from '../logger';\nimport { roomAudioPlaybackAllowedObservable } from '../observables/room';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupStartAudio() {\n  const handleStartAudioPlayback = async (room: Room) => {\n    log.info('Start Audio for room: ', room);\n    await room.startAudio();\n  };\n  const className: string = prefixClass('start-audio-button');\n  return { className, roomAudioPlaybackAllowedObservable, handleStartAudioPlayback };\n}\n","import type { Room } from 'livekit-client';\nimport { log } from '../logger';\nimport { roomVideoPlaybackAllowedObservable } from '../observables/room';\nimport { prefixClass } from '../styles-interface';\n\nexport function setupStartVideo() {\n  const handleStartVideoPlayback = async (room: Room) => {\n    log.info('Start Video for room: ', room);\n    await room.startVideo();\n  };\n  const className: string = prefixClass('start-audio-button');\n  return { className, roomVideoPlaybackAllowedObservable, handleStartVideoPlayback };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupChatToggle() {\n  const className: string = [prefixClass('button'), prefixClass('chat-toggle')].join(' ');\n  return { className };\n}\n","import { prefixClass } from '../styles-interface';\n\nexport function setupFocusToggle() {\n  const className: string = [prefixClass('button'), prefixClass('focus-toggle-button')].join(' ');\n  return { className };\n}\n","// import { prefixClass } from '../styles-interface';\n\nexport function setupClearPinButton() {\n  // const className = prefixClass('clear-pin-button');\n  const className = 'lk-clear-pin-button lk-button';\n  return { className };\n}\n","export function setupLiveKitRoom() {\n  const className = 'lk-room-container';\n  return { className };\n}\n","import type {\n  LocalTrackPublication,\n  Participant,\n  RemoteTrackPublication,\n  Room,\n  Track,\n  TrackPublication,\n} from 'livekit-client';\nimport { RoomEvent, TrackEvent } from 'livekit-client';\nimport { map, Observable, startWith } from 'rxjs';\nimport { allParticipantRoomEvents } from '../helper';\nimport { log } from '../logger';\nimport type { TrackReference } from '../track-reference';\nimport { observeRoomEvents } from './room';\n\nexport function trackObservable(track: TrackPublication) {\n  const trackObserver = observeTrackEvents(\n    track,\n    TrackEvent.Muted,\n    TrackEvent.Unmuted,\n    TrackEvent.Subscribed,\n    TrackEvent.Unsubscribed,\n  );\n\n  return trackObserver;\n}\n\nexport function observeTrackEvents(track: TrackPublication, ...events: TrackEvent[]) {\n  const observable = new Observable<TrackPublication>((subscribe) => {\n    const onTrackUpdate = () => {\n      subscribe.next(track);\n    };\n\n    events.forEach((evt) => {\n      // @ts-expect-error type of `TrackEvent` and `PublicationCallbacks` are congruent\n      track.on(evt, onTrackUpdate);\n    });\n\n    const unsubscribe = () => {\n      events.forEach((evt) => {\n        // @ts-expect-error type of `TrackEvent` and `PublicationCallbacks` are congruent\n        track.off(evt, onTrackUpdate);\n      });\n    };\n    return unsubscribe;\n  }).pipe(startWith(track));\n\n  return observable;\n}\n\n/**\n * Create `TrackReferences` for all tracks that are included in the sources property.\n *  */\nfunction getTrackReferences(\n  room: Room,\n  sources: Track.Source[],\n  onlySubscribedTracks = true,\n): { trackReferences: TrackReference[]; participants: Participant[] } {\n  const localParticipant = room.localParticipant;\n  const allParticipants = [localParticipant, ...Array.from(room.participants.values())];\n  const trackReferences: TrackReference[] = [];\n\n  allParticipants.forEach((participant) => {\n    sources.forEach((source) => {\n      const sourceReferences = Array.from<RemoteTrackPublication | LocalTrackPublication>(\n        participant.tracks.values(),\n      )\n        .filter(\n          (track) =>\n            track.source === source &&\n            // either return all or only the ones that are subscribed\n            (!onlySubscribedTracks || track.track),\n        )\n        .map((track): TrackReference => {\n          return {\n            participant: participant,\n            publication: track,\n            source: track.source,\n          };\n        });\n\n      trackReferences.push(...sourceReferences);\n    });\n  });\n\n  return { trackReferences, participants: allParticipants };\n}\n\ntype TrackReferencesObservableOptions = {\n  additionalRoomEvents?: RoomEvent[];\n  onlySubscribed?: boolean;\n};\n\nexport function trackReferencesObservable(\n  room: Room,\n  sources: Track.Source[],\n  options: TrackReferencesObservableOptions,\n): Observable<{ trackReferences: TrackReference[]; participants: Participant[] }> {\n  const additionalRoomEvents = options.additionalRoomEvents ?? allParticipantRoomEvents;\n  const onlySubscribedTracks: boolean = options.onlySubscribed ?? true;\n  const roomEvents = Array.from(\n    new Set([\n      RoomEvent.ParticipantConnected,\n      RoomEvent.ParticipantDisconnected,\n      RoomEvent.ConnectionStateChanged,\n      RoomEvent.LocalTrackPublished,\n      RoomEvent.LocalTrackUnpublished,\n      RoomEvent.TrackPublished,\n      RoomEvent.TrackUnpublished,\n      RoomEvent.TrackSubscriptionStatusChanged,\n      ...additionalRoomEvents,\n    ]).values(),\n  );\n\n  const observable = observeRoomEvents(room, ...roomEvents).pipe(\n    map((room) => {\n      const data = getTrackReferences(room, sources, onlySubscribedTracks);\n      log.debug(`TrackReference[] was updated. (length ${data.trackReferences.length})`, data);\n      return data;\n    }),\n    startWith(getTrackReferences(room, sources, onlySubscribedTracks)),\n  );\n\n  return observable;\n}\n","import type { Observable } from 'rxjs';\nimport { concat, distinctUntilChanged, fromEvent, map, of, skipUntil, timeout } from 'rxjs';\n\n/**\n * Returns true if the user is interacting with the HTML element,\n * and returns false if there is no interaction for a specified period of time.\n *\n * @internal\n */\nexport function createInteractingObservable(htmlElement: HTMLElement | null, inactiveAfter = 1000) {\n  if (htmlElement === null) return of(false);\n  const move$ = fromEvent(htmlElement, 'mousemove', { passive: true }).pipe(map(() => true));\n  const moveAndStop$: Observable<boolean> = move$.pipe(\n    timeout({\n      each: inactiveAfter,\n      with: () => concat(of(false), moveAndStop$.pipe(skipUntil(move$))),\n    }),\n    distinctUntilChanged(),\n  );\n  return moveAndStop$;\n}\n","import { log } from '../logger';\n\ntype JsonPrimitive = string | number | boolean | null;\ntype JsonArray = JsonValue[];\ntype JsonObject = { [key: string]: JsonValue };\ntype JsonValue = JsonPrimitive | JsonArray | JsonObject;\n\n/**\n * Persists a serializable object to local storage associated with the specified key.\n * @internal\n */\nfunction saveToLocalStorage<T extends JsonValue>(key: string, value: T): void {\n  if (typeof localStorage === 'undefined') {\n    log.error('Local storage is not available.');\n    return;\n  }\n\n  try {\n    localStorage.setItem(key, JSON.stringify(value));\n  } catch (error) {\n    log.error(`Error setting item to local storage: ${error}`);\n  }\n}\n\n/**\n * Retrieves a serializable object from local storage by its key.\n * @internal\n */\nfunction loadFromLocalStorage<T extends JsonValue>(key: string): T | undefined {\n  if (typeof localStorage === 'undefined') {\n    log.error('Local storage is not available.');\n    return undefined;\n  }\n\n  try {\n    const item = localStorage.getItem(key);\n    if (!item) {\n      log.warn(`Item with key ${key} does not exist in local storage.`);\n      return undefined;\n    }\n    return JSON.parse(item);\n  } catch (error) {\n    log.error(`Error getting item from local storage: ${error}`);\n    return undefined;\n  }\n}\n\n/**\n * Generate a pair of functions to load and save a value of type T to local storage.\n * @internal\n */\nexport function createLocalStorageInterface<T extends JsonValue>(\n  key: string,\n): { load: () => T | undefined; save: (value: T) => void } {\n  return {\n    load: () => loadFromLocalStorage<T>(key),\n    save: (value: T) => saveToLocalStorage<T>(key, value),\n  };\n}\n","import { cssPrefix } from '../constants';\nimport { createLocalStorageInterface } from './local-storage-helpers';\n\nconst USER_CHOICES_KEY = `${cssPrefix}-user-choices` as const;\n\n/**\n * @public\n * Represents the user's choices for video and audio input devices,\n * as well as their username.\n */\nexport type LocalUserChoices = {\n  /**\n   * Whether video input is enabled.\n   * @defaultValue `true`\n   */\n  videoEnabled: boolean;\n  /**\n   * Whether audio input is enabled.\n   * @defaultValue `true`\n   */\n  audioEnabled: boolean;\n  /**\n   * The device ID of the video input device to use.\n   * @defaultValue `''`\n   */\n  videoDeviceId: string;\n  /**\n   * The device ID of the audio input device to use.\n   * @defaultValue `''`\n   */\n  audioDeviceId: string;\n  /**\n   * The username to use.\n   * @defaultValue `''`\n   */\n  username: string;\n  /** @deprecated This property will be removed without replacement. */\n  e2ee: boolean;\n  /** @deprecated This property will be removed without replacement. */\n  sharedPassphrase: string;\n};\n\nconst defaultUserChoices: LocalUserChoices = {\n  videoEnabled: true,\n  audioEnabled: true,\n  videoDeviceId: '',\n  audioDeviceId: '',\n  username: '',\n  e2ee: false,\n  sharedPassphrase: '',\n} as const;\n\n/**\n * The type of the object stored in local storage.\n * @remarks\n * TODO: Replace this type with `LocalUserChoices` after removing the deprecated properties from `LocalUserChoices`.\n * @internal\n */\ntype TempStorageType = Omit<LocalUserChoices, 'e2ee' | 'sharedPassphrase'>;\nconst { load, save } = createLocalStorageInterface<TempStorageType>(USER_CHOICES_KEY);\n\n/**\n * Saves user choices to local storage.\n * @alpha\n */\nexport function saveUserChoices(\n  userChoices: LocalUserChoices,\n  /**\n   * Whether to prevent saving user choices to local storage.\n   */\n  preventSave: boolean = false,\n): void {\n  if (preventSave === true) {\n    return;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { e2ee, sharedPassphrase, ...toSave } = userChoices;\n  save(toSave);\n}\n\n/**\n * Reads the user choices from local storage, or returns the default settings if none are found.\n * @remarks\n * The deprecated parameters `e2ee` and `sharedPassphrase` are not read from local storage\n * and always return the value from the passed `defaults` or internal defaults.\n * @alpha\n */\nexport function loadUserChoices(\n  defaults?: Partial<LocalUserChoices>,\n  /**\n   * Whether to prevent loading from local storage and return default values instead.\n   * @defaultValue false\n   */\n  preventLoad: boolean = false,\n): LocalUserChoices {\n  const fallback: LocalUserChoices = {\n    videoEnabled: defaults?.videoEnabled ?? defaultUserChoices.videoEnabled,\n    audioEnabled: defaults?.audioEnabled ?? defaultUserChoices.audioEnabled,\n    videoDeviceId: defaults?.videoDeviceId ?? defaultUserChoices.videoDeviceId,\n    audioDeviceId: defaults?.audioDeviceId ?? defaultUserChoices.audioDeviceId,\n    username: defaults?.username ?? defaultUserChoices.username,\n    e2ee: defaults?.e2ee ?? defaultUserChoices.e2ee,\n    sharedPassphrase: defaults?.sharedPassphrase ?? defaultUserChoices.sharedPassphrase,\n  };\n\n  if (preventLoad) {\n    return fallback;\n  } else {\n    const maybeLoadedObject = load();\n    const result = { ...fallback, ...(maybeLoadedObject ?? {}) };\n    return result;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}